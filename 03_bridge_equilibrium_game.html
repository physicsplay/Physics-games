<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Î•Ï€Î¹Ï‡ÎµÎ¯ÏÎ·ÏƒÎ· Î“Î­Ï†Ï…ÏÎ± - Î™ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î± Î£Ï„ÎµÏÎµÎ¿Ï</title>
<style>
:root {
  --bg: #0a1628;
  --panel: rgba(20, 40, 80, 0.95);
  --accent: #4ECDC4;
  --gold: #FFD700;
  --warn: #FF6B6B;
  --success: #2ecc71;
  --blueprint: #1a3a5c;
  --grid: rgba(78, 205, 196, 0.15);
}

* { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; width: 100%; background: var(--bg); overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: #fff; }
body { display: flex; justify-content: center; align-items: center; }

#game-container {
  position: relative;
  width: 1200px;
  height: 750px;
  border-radius: 14px;
  overflow: hidden;
  box-shadow: 0 0 50px rgba(0,0,0,0.55);
  background: var(--blueprint);
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
}

/* HUD Panels */
.hud-panel {
  position: absolute;
  padding: 14px;
  border-radius: 12px;
  backdrop-filter: blur(8px);
  border: 1px solid rgba(78, 205, 196, 0.25);
  background: var(--panel);
  font-size: 13px;
  line-height: 1.4;
}

.hud-top-left { top: 10px; left: 10px; width: 200px; }
.hud-top-right { top: 10px; right: 10px; width: 280px; }
.hud-bottom { bottom: 10px; left: 50%; transform: translateX(-50%); width: 500px; text-align: center; }
.hud-physics { bottom: 10px; right: 10px; width: 300px; }

h2 { font-size: 14px; color: var(--gold); margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.12); padding-bottom: 4px; }
h3 { font-size: 16px; color: var(--accent); margin-bottom: 8px; }

.stat-row { display: flex; justify-content: space-between; margin: 5px 0; }
.val { font-weight: 700; color: var(--accent); }
.val.warn { color: var(--warn); }
.val.success { color: var(--success); }

.formula-box {
  background: rgba(255,215,0,0.08);
  padding: 10px;
  border-radius: 8px;
  border-left: 3px solid var(--gold);
  margin: 8px 0;
  font-size: 12px;
}
.formula { font-family: "Times New Roman", serif; font-size: 15px; color: #fff; margin: 4px 0; }

/* Input fields */
.input-group {
  display: flex;
  gap: 10px;
  margin: 10px 0;
  flex-wrap: wrap;
}
.input-field {
  flex: 1;
  min-width: 100px;
}
.input-field label {
  display: block;
  font-size: 11px;
  color: var(--accent);
  margin-bottom: 4px;
}
.input-field input {
  width: 100%;
  padding: 8px 10px;
  border-radius: 8px;
  border: 2px solid rgba(78, 205, 196, 0.3);
  background: rgba(0,0,0,0.3);
  color: #fff;
  font-size: 14px;
  font-weight: 700;
  text-align: center;
}
.input-field input:focus {
  outline: none;
  border-color: var(--gold);
}

/* Buttons */
button {
  background: linear-gradient(135deg, var(--accent), #3498db);
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 999px;
  font-size: 14px;
  font-weight: 800;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
  margin: 5px;
}
button:hover { transform: scale(1.03); box-shadow: 0 0 15px rgba(78, 205, 196, 0.4); }
button.primary { background: linear-gradient(135deg, var(--gold), #FFA500); color: #1a1a2e; }
button.warn { background: linear-gradient(135deg, var(--warn), #e74c3c); }
button.small { padding: 6px 12px; font-size: 12px; }

/* Screens */
.screen {
  position: absolute;
  inset: 0;
  background: rgba(10, 22, 40, 0.97);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  overflow-y: auto;
  padding: 20px;
}
.screen.hidden { display: none; }

.modal {
  width: min(800px, calc(100vw - 40px));
  max-height: calc(100vh - 40px);
  overflow-y: auto;
  text-align: center;
  padding: 28px;
  background: linear-gradient(145deg, #1a2a4a, #0f1f3a);
  border: 2px solid var(--accent);
  border-radius: 20px;
  box-shadow: 0 0 60px rgba(78, 205, 196, 0.15);
}
.modal h1 { color: var(--gold); font-size: 32px; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255,215,0,0.3); }
.modal p { margin: 10px 0; color: #ccc; font-size: 14px; line-height: 1.6; }

.modal-section {
  background: rgba(255,255,255,0.05);
  padding: 15px;
  border-radius: 12px;
  margin: 15px 0;
  text-align: left;
}
.modal-section h4 { color: var(--gold); margin-bottom: 10px; font-size: 14px; }

/* Level selector */
.level-selector { display: flex; flex-direction: column; gap: 8px; }
.level-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: rgba(255,255,255,0.05);
  border: 2px solid transparent;
  border-radius: 10px;
  cursor: pointer;
  transition: 0.2s;
}
.level-option:hover { background: rgba(255,255,255,0.08); border-color: rgba(78, 205, 196, 0.3); }
.level-option.selected { background: rgba(78, 205, 196, 0.15); border-color: var(--accent); }
.level-option input { transform: scale(1.2); }
.level-label { flex: 1; }
.level-label strong { color: var(--accent); display: block; margin-bottom: 2px; }
.level-label span { font-size: 11px; color: #999; }

/* Language buttons */
.lang-row { display: flex; gap: 10px; justify-content: center; margin: 10px 0; flex-wrap: wrap; }
.lang-btn {
  padding: 8px 14px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.05);
  color: #fff;
  font-weight: 700;
  cursor: pointer;
  transition: 0.15s;
}
.lang-btn.selected { border-color: var(--gold); background: rgba(255,215,0,0.15); }

/* Medal display */
.medal { font-size: 80px; margin: 20px 0; text-shadow: 0 0 30px rgba(255,215,0,0.4); }
.success-stat {
  display: inline-block;
  background: rgba(78, 205, 196, 0.15);
  padding: 8px 16px;
  border-radius: 999px;
  margin: 5px;
  font-size: 13px;
}

/* Load display */
.load-item {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: rgba(255,107,107,0.15);
  border: 1px solid rgba(255,107,107,0.3);
  border-radius: 8px;
  margin: 4px;
  font-size: 12px;
  cursor: grab;
}
.load-item:active { cursor: grabbing; }
.load-item .emoji { font-size: 20px; }

/* Result feedback */
.result-box {
  padding: 12px;
  border-radius: 10px;
  margin: 10px 0;
  font-size: 13px;
}
.result-box.correct { background: rgba(46, 204, 113, 0.2); border: 1px solid var(--success); }
.result-box.wrong { background: rgba(255, 107, 107, 0.2); border: 1px solid var(--warn); }

/* Hints panel */
.hint-box {
  background: rgba(255, 215, 0, 0.1);
  border: 1px solid rgba(255, 215, 0, 0.3);
  padding: 12px;
  border-radius: 10px;
  margin-top: 10px;
  font-size: 12px;
  text-align: left;
  display: none;
}
.hint-box.visible { display: block; }

/* Timer warning */
@keyframes urgentPulse {
  0%, 100% { background: rgba(255, 107, 107, 0.2); }
  50% { background: rgba(255, 107, 107, 0.4); }
}
.urgent { animation: urgentPulse 0.5s infinite; }

/* Responsive */
@media (max-width: 900px) {
  #game-container { width: 100vw; height: 100vh; border-radius: 0; }
  .hud-physics { display: none; }
  .hud-bottom { width: calc(100% - 20px); }
}
</style>
</head>
<body>

<div id="game-container">
  <canvas id="canvas" width="1200" height="750"></canvas>

  <!-- HUD: Score & Attempts -->
  <div class="hud-panel hud-top-left" id="hudScore">
    <h2 id="lblScoreTitle">ğŸ¯ Î ÏÏŒÎ¿Î´Î¿Ï‚</h2>
    <div class="stat-row">
      <span id="lblLevel">Î•Ï€Î¯Ï€ÎµÎ´Î¿:</span>
      <span class="val" id="levelDisp">1/5</span>
    </div>
    <div class="stat-row">
      <span id="lblAttempts">Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚:</span>
      <span class="val" id="attemptsDisp">0</span>
    </div>
    <div class="stat-row">
      <span id="lblScore">Î’Î±Î¸Î¼ÏŒÏ‚:</span>
      <span class="val" id="scoreDisp">100</span>
    </div>
    <div class="stat-row">
      <span id="lblTime">Î§ÏÏŒÎ½Î¿Ï‚:</span>
      <span class="val" id="timeDisp">5:00</span>
    </div>
  </div>

  <!-- HUD: Bridge Info -->
  <div class="hud-panel hud-top-right" id="hudBridge">
    <h2 id="lblBridgeTitle">ğŸŒ‰ Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î± Î“Î­Ï†Ï…ÏÎ±Ï‚</h2>
    <div class="stat-row">
      <span id="lblBridgeLen">ÎœÎ®ÎºÎ¿Ï‚ Î³Î­Ï†Ï…ÏÎ±Ï‚ L:</span>
      <span class="val" id="bridgeLenDisp">10.0 m</span>
    </div>
    <div class="stat-row">
      <span id="lblBridgeWeight">Î’Î¬ÏÎ¿Ï‚ Î³Î­Ï†Ï…ÏÎ±Ï‚ W<sub>Î³</sub>:</span>
      <span class="val" id="bridgeWeightDisp">5.0 kN</span>
    </div>
    <div id="loadsContainer">
      <div style="margin-top: 10px; font-size: 12px; color: var(--gold);" id="lblLoads">ğŸ“¦ Î¦Î¿ÏÏ„Î¯Î±:</div>
      <div id="loadsList"></div>
    </div>
    <div class="stat-row" style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
      <span id="lblTotalLoad">Î£Ï…Î½Î¿Î»Î¹ÎºÏŒ Ï†Î¿ÏÏ„Î¯Î¿:</span>
      <span class="val warn" id="totalLoadDisp">0 kN</span>
    </div>
  </div>

  <!-- HUD: Input Panel -->
  <div class="hud-panel hud-bottom" id="hudInput">
    <h3 id="lblInputTitle">ğŸ“ Î¥Ï€Î¿Î»ÏŒÎ³Î¹ÏƒÎµ Ï„Î¹Ï‚ Î‘Î½Ï„Î¹Î´ÏÎ¬ÏƒÎµÎ¹Ï‚</h3>
    <p style="font-size: 11px; color: #aaa; margin-bottom: 10px;" id="lblInputHint">
      Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¹Ï‚ ÏƒÏ…Î½Î¸Î®ÎºÎµÏ‚ Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚: Î£F = 0 ÎºÎ±Î¹ Î£Ï„ = 0
    </p>
    <div class="input-group">
      <div class="input-field">
        <label id="lblRA">R<sub>A</sub> (Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ ÏƒÏ„Î®ÏÎ¹Î³Î¼Î±) ÏƒÎµ kN:</label>
        <input type="number" id="inputRA" step="0.1" placeholder="0.0">
      </div>
      <div class="input-field">
        <label id="lblRB">R<sub>B</sub> (Î”ÎµÎ¾Î¯ ÏƒÏ„Î®ÏÎ¹Î³Î¼Î±) ÏƒÎµ kN:</label>
        <input type="number" id="inputRB" step="0.1" placeholder="0.0">
      </div>
    </div>
    <div>
      <button class="primary" id="btnCheck">âœ“ Î•Î›Î•Î“Î§ÎŸÎ£</button>
      <button id="btnHint">ğŸ’¡ Î¥Ï€ÏŒÎ´ÎµÎ¹Î¾Î· (-5 Î²Î±Î¸Î¼Î¿Î¯)</button>
      <button class="warn" id="btnReset">â†º Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬</button>
    </div>
    <div class="hint-box" id="hintBox"></div>
    <div id="resultBox"></div>
  </div>

  <!-- HUD: Physics Formulas -->
  <div class="hud-panel hud-physics" id="hudPhysics">
    <h2 id="lblPhysicsTitle">ğŸ“š Î£Ï…Î½Î¸Î®ÎºÎµÏ‚ Î™ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚</h2>
    <div class="formula-box">
      <div class="formula">Î£F<sub>y</sub> = 0</div>
      <div style="font-size: 11px; color: #aaa;">R<sub>A</sub> + R<sub>B</sub> = W<sub>Î³</sub> + Î£W<sub>i</sub></div>
    </div>
    <div class="formula-box">
      <div class="formula">Î£Ï„<sub>A</sub> = 0</div>
      <div style="font-size: 11px; color: #aaa;">R<sub>B</sub>Â·L = W<sub>Î³</sub>Â·(L/2) + Î£(W<sub>i</sub>Â·x<sub>i</sub>)</div>
    </div>
    <div class="formula-box">
      <div style="font-size: 11px; color: var(--accent);">
        ğŸ’¡ Î¡Î¿Ï€Î®: Ï„ = F Â· d<br>
        (d = ÎºÎ¬Î¸ÎµÏ„Î· Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ· Î±Ï€ÏŒ Î¬Î¾Î¿Î½Î±)
      </div>
    </div>
  </div>

  <!-- Intro Screen -->
  <div class="screen" id="introScreen">
    <div class="modal">
      <h1 id="introTitle">ğŸŒ‰ Î•Î Î™Î§Î•Î™Î¡Î—Î£Î— Î“Î•Î¦Î¥Î¡Î‘</h1>
      
      <div class="modal-section" style="text-align: center;">
        <h4 id="langTitle">ğŸŒ Î“Î»ÏÏƒÏƒÎ± / Language / Lingua</h4>
        <div class="lang-row">
          <button type="button" class="lang-btn selected" data-lang="el">ğŸ‡¬ğŸ‡· Î•Î»Î»Î·Î½Î¹ÎºÎ¬</button>
          <button type="button" class="lang-btn" data-lang="en">ğŸ‡¬ğŸ‡§ English</button>
          <button type="button" class="lang-btn" data-lang="it">ğŸ‡®ğŸ‡¹ Italiano</button>
        </div>
      </div>

      <div class="modal-section">
        <h4 id="scenarioHdr">ğŸš¨ Î¤Î¿ Î£ÎµÎ½Î¬ÏÎ¹Î¿</h4>
        <p id="scenarioBody"></p>
      </div>

      <div class="modal-section">
        <h4 id="levelHdr">ğŸ“Š Î•Ï€Î¯Ï€ÎµÎ´Î¿ Î”Ï…ÏƒÎºÎ¿Î»Î¯Î±Ï‚</h4>
        <div class="level-selector" id="levelSelector"></div>
      </div>

      <div class="modal-section">
        <h4 id="howtoHdr">ğŸ“– Î ÏÏ‚ Ï€Î±Î¯Î¶ÎµÏ„Î±Î¹</h4>
        <p id="howtoBody"></p>
      </div>

      <div class="modal-section">
        <h4 id="scoringHdr">ğŸ… Î’Î±Î¸Î¼Î¿Î»Î¿Î³Î¯Î±</h4>
        <p id="scoringBody"></p>
      </div>

      <button class="primary" id="startBtn" style="font-size: 18px; padding: 14px 32px;">
        ğŸš§ ÎÎ•ÎšÎ™ÎÎ‘ Î¤Î—Î ÎšÎ‘Î¤Î‘Î£ÎšÎ•Î¥Î—!
      </button>
      <p style="font-size: 11px; color: #777; margin-top: 10px;" id="schoolLine">
        2Î¿ Î›ÏÎºÎµÎ¹Î¿ ÎœÎ¿ÏƒÏ‡Î¬Ï„Î¿Ï… - Î¦Ï…ÏƒÎ¹ÎºÎ® Î“' Î›Ï…ÎºÎµÎ¯Î¿Ï…
      </p>
    </div>
  </div>

  <!-- End Screen -->
  <div class="screen hidden" id="endScreen">
    <div class="modal">
      <h1 id="endTitle">Î¤Î™Î¤Î›ÎŸÎ£</h1>
      <div id="endMedal" class="medal">ğŸ†</div>
      <div id="endMessage"></div>
      <button class="primary" id="btnRestart">ğŸ”„ ÎÎ­Î± Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®</button>
    </div>
  </div>
</div>

<script>
/* ========================================
   MULTI-LANGUAGE STRINGS
   ======================================== */
const I18N = {
  el: {
    title: "Î•Ï€Î¹Ï‡ÎµÎ¯ÏÎ·ÏƒÎ· Î“Î­Ï†Ï…ÏÎ± - Î™ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î± Î£Ï„ÎµÏÎµÎ¿Ï",
    introTitle: "ğŸŒ‰ Î•Î Î™Î§Î•Î™Î¡Î—Î£Î— Î“Î•Î¦Î¥Î¡Î‘",
    langTitle: "ğŸŒ Î“Î»ÏÏƒÏƒÎ±",
    scenarioHdr: "ğŸš¨ Î¤Î¿ Î£ÎµÎ½Î¬ÏÎ¹Î¿",
    scenarioBody: `<strong style="color: var(--warn);">Î•ÎšÎ¤Î‘ÎšÎ¤ÎŸ!</strong> Î— ÎºÎ±Ï„Î±Î¹Î³Î¯Î´Î± ÎºÎ±Ï„Î­ÏƒÏ„ÏÎµÏˆÎµ Ï„Î· Î³Î­Ï†Ï…ÏÎ± Ï„Î¿Ï… Ï€Î¿Ï„Î±Î¼Î¿Ï!<br><br>
      ğŸš‘ Î¤Î¿ Î±ÏƒÎ¸ÎµÎ½Î¿Ï†ÏŒÏÎ¿ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€ÎµÏÎ¬ÏƒÎµÎ¹ Î³Î¹Î± Î½Î± Ï€Î¬ÎµÎ¹ ÏƒÏ„Î¿ Ï‡Ï‰ÏÎ¹ÏŒ.<br>
      ğŸ—ï¸ Î— Î¿Î¼Î¬Î´Î± Î´Î¹Î¬ÏƒÏ‰ÏƒÎ·Ï‚ Ï„Î¿Ï… ÏƒÏ‡Î¿Î»ÎµÎ¯Î¿Ï… Ï†Ï„Î¹Î¬Ï‡Î½ÎµÎ¹ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ· Î³Î­Ï†Ï…ÏÎ± Î±Ï€ÏŒ Î´Î¿ÎºÎ¿ÏÏ‚.<br><br>
      <strong style="color: var(--accent);">Î— Î±Ï€Î¿ÏƒÏ„Î¿Î»Î® ÏƒÎ¿Ï…:</strong> Î¥Ï€Î¿Î»ÏŒÎ³Î¹ÏƒÎµ Ï„Î¹Ï‚ Î±Î½Ï„Î¹Î´ÏÎ¬ÏƒÎµÎ¹Ï‚ Ï„Ï‰Î½ ÏƒÏ„Î·ÏÎ¹Î³Î¼Î¬Ï„Ï‰Î½ ÏÏƒÏ„Îµ Î· Î³Î­Ï†Ï…ÏÎ± Î½Î± Î±Î½Ï„Î­Î¾ÎµÎ¹!<br>
      Î‘Î½ Î¿Î¹ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿Î¯ ÎµÎ¯Î½Î±Î¹ Î»Î¬Î¸Î¿Ï‚... Î· Î³Î­Ï†Ï…ÏÎ± Î¸Î± ÎºÎ±Ï„Î±ÏÏÎµÏÏƒÎµÎ¹! ğŸ’¥`,
    levelHdr: "ğŸ“Š Î•Ï€Î¯Ï€ÎµÎ´Î¿ Î”Ï…ÏƒÎºÎ¿Î»Î¯Î±Ï‚",
    levels: [
      { name: "Î•Ï€Î¯Ï€ÎµÎ´Î¿ 1: ÎˆÎ½Î± Ï†Î¿ÏÏ„Î¯Î¿ ÏƒÏ„Î¿ ÎºÎ­Î½Ï„ÏÎ¿", desc: "Î•ÏÎºÎ¿Î»Î¿ - Î£Ï…Î¼Î¼ÎµÏ„ÏÎ¹ÎºÎ® Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ·" },
      { name: "Î•Ï€Î¯Ï€ÎµÎ´Î¿ 2: Î¦Î¿ÏÏ„Î¯Î¿ ÎµÎºÏ„ÏŒÏ‚ ÎºÎ­Î½Ï„ÏÎ¿Ï…", desc: "ÎœÎ­Ï„ÏÎ¹Î¿ - Î‘ÏƒÏÎ¼Î¼ÎµÏ„ÏÎ· Ï†ÏŒÏÏ„Î¹ÏƒÎ·" },
      { name: "Î•Ï€Î¯Ï€ÎµÎ´Î¿ 3: Î”ÏÎ¿ Ï†Î¿ÏÏ„Î¯Î±", desc: "Î”ÏÏƒÎºÎ¿Î»Î¿ - Î Î¿Î»Î»Î±Ï€Î»Î¬ Ï†Î¿ÏÏ„Î¯Î±" },
      { name: "Î•Ï€Î¯Ï€ÎµÎ´Î¿ 4: ÎšÎ¹Î½Î¿ÏÎ¼ÎµÎ½Î¿ ÏŒÏ‡Î·Î¼Î±", desc: "Î ÏÏŒÎºÎ»Î·ÏƒÎ· - Î¤Î¿ Ï†Î¿ÏÏ„Î¯Î¿ Î±Î»Î»Î¬Î¶ÎµÎ¹ Î¸Î­ÏƒÎ·" },
      { name: "Î•Ï€Î¯Ï€ÎµÎ´Î¿ 5: Î Î»Î®ÏÎ·Ï‚ Î±Ï€Î¿ÏƒÏ„Î¿Î»Î®", desc: "Expert - Î‘ÏƒÎ¸ÎµÎ½Î¿Ï†ÏŒÏÎ¿ + ÎµÎ¾Î¿Ï€Î»Î¹ÏƒÎ¼ÏŒÏ‚" }
    ],
    howtoHdr: "ğŸ“– Î ÏÏ‚ Ï€Î±Î¯Î¶ÎµÏ„Î±Î¹",
    howtoBody: `1. Î”ÎµÏ‚ Ï„Î± Ï†Î¿ÏÏ„Î¯Î± ÏƒÏ„Î· Î³Î­Ï†Ï…ÏÎ± ÎºÎ±Î¹ Ï„Î¹Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚ Ï„Î¿Ï…Ï‚<br>
      2. Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¹Ï‚ <strong>ÏƒÏ…Î½Î¸Î®ÎºÎµÏ‚ Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚</strong>:<br>
      &nbsp;&nbsp;&nbsp;â€¢ Î£F<sub>y</sub> = 0 (Î¬Î¸ÏÎ¿Î¹ÏƒÎ¼Î± ÎºÎ±Ï„Î±ÎºÏŒÏÏ…Ï†Ï‰Î½ Î´Ï…Î½Î¬Î¼ÎµÏ‰Î½ = 0)<br>
      &nbsp;&nbsp;&nbsp;â€¢ Î£Ï„ = 0 (Î¬Î¸ÏÎ¿Î¹ÏƒÎ¼Î± ÏÎ¿Ï€ÏÎ½ Ï‰Ï‚ Ï€ÏÎ¿Ï‚ ÏƒÎ·Î¼ÎµÎ¯Î¿ = 0)<br>
      3. Î¥Ï€Î¿Î»ÏŒÎ³Î¹ÏƒÎµ Ï„Î¹Ï‚ Î±Î½Ï„Î¹Î´ÏÎ¬ÏƒÎµÎ¹Ï‚ R<sub>A</sub> ÎºÎ±Î¹ R<sub>B</sub><br>
      4. Î•Î¹ÏƒÎ¬Î³Î±Î³Îµ Ï„Î¹Ï‚ Ï„Î¹Î¼Î­Ï‚ ÎºÎ±Î¹ Ï€Î¬Ï„Î± "ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚"<br>
      5. Î‘Î½ ÎµÎ¯Î½Î±Î¹ ÏƒÏ‰ÏƒÏ„Î­Ï‚, Ï€ÎµÏÎ½Î¬Ï‚ ÏƒÏ„Î¿ ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿ ÎµÏ€Î¯Ï€ÎµÎ´Î¿!`,
    scoringHdr: "ğŸ… Î’Î±Î¸Î¼Î¿Î»Î¿Î³Î¯Î±",
    scoringBody: `â€¢ <strong>70%</strong> Î±Ï€ÏŒ Ï„Î¹Ï‚ Ï€ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚ (ÎºÎ¬Î¸Îµ Î»Î¬Î¸Î¿Ï‚: -10 Î²Î±Î¸Î¼Î¿Î¯)<br>
      â€¢ <strong>30%</strong> Î±Ï€ÏŒ Ï„Î·Î½ Î±ÎºÏÎ¯Î²ÎµÎ¹Î± (Ï€ÏŒÏƒÎ¿ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î· ÏƒÏ‰ÏƒÏ„Î® Ï„Î¹Î¼Î®)<br>
      â€¢ ğŸ¥‡ Î§ÏÏ…ÏƒÏŒ: ÏƒÏ†Î¬Î»Î¼Î± < 2% | ğŸ¥ˆ Î‘ÏƒÎ·Î¼Î­Î½Î¹Î¿: < 5% | ğŸ¥‰ Î§Î¬Î»ÎºÎ¹Î½Î¿: < 10%<br>
      â€¢ ğŸ’¡ Î¥Ï€Î¿Î´ÎµÎ¯Î¾ÎµÎ¹Ï‚: -5 Î²Î±Î¸Î¼Î¿Î¯ Î· ÎºÎ¬Î¸Îµ Î¼Î¯Î±`,
    startBtn: "ğŸš§ ÎÎ•ÎšÎ™ÎÎ‘ Î¤Î—Î ÎšÎ‘Î¤Î‘Î£ÎšÎ•Î¥Î—!",
    schoolLine: "2Î¿ Î›ÏÎºÎµÎ¹Î¿ ÎœÎ¿ÏƒÏ‡Î¬Ï„Î¿Ï… - Î¦Ï…ÏƒÎ¹ÎºÎ® Î“' Î›Ï…ÎºÎµÎ¯Î¿Ï…",
    
    // HUD
    lblScoreTitle: "ğŸ¯ Î ÏÏŒÎ¿Î´Î¿Ï‚",
    lblLevel: "Î•Ï€Î¯Ï€ÎµÎ´Î¿:",
    lblAttempts: "Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚:",
    lblScore: "Î’Î±Î¸Î¼ÏŒÏ‚:",
    lblTime: "Î§ÏÏŒÎ½Î¿Ï‚:",
    lblBridgeTitle: "ğŸŒ‰ Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î± Î“Î­Ï†Ï…ÏÎ±Ï‚",
    lblBridgeLen: "ÎœÎ®ÎºÎ¿Ï‚ Î³Î­Ï†Ï…ÏÎ±Ï‚ L:",
    lblBridgeWeight: "Î’Î¬ÏÎ¿Ï‚ Î³Î­Ï†Ï…ÏÎ±Ï‚ W_Î³:",
    lblLoads: "ğŸ“¦ Î¦Î¿ÏÏ„Î¯Î±:",
    lblTotalLoad: "Î£Ï…Î½Î¿Î»Î¹ÎºÏŒ Ï†Î¿ÏÏ„Î¯Î¿:",
    lblInputTitle: "ğŸ“ Î¥Ï€Î¿Î»ÏŒÎ³Î¹ÏƒÎµ Ï„Î¹Ï‚ Î‘Î½Ï„Î¹Î´ÏÎ¬ÏƒÎµÎ¹Ï‚",
    lblInputHint: "Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¹Ï‚ ÏƒÏ…Î½Î¸Î®ÎºÎµÏ‚ Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚: Î£F = 0 ÎºÎ±Î¹ Î£Ï„ = 0",
    lblRA: "R_A (Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ ÏƒÏ„Î®ÏÎ¹Î³Î¼Î±) ÏƒÎµ kN:",
    lblRB: "R_B (Î”ÎµÎ¾Î¯ ÏƒÏ„Î®ÏÎ¹Î³Î¼Î±) ÏƒÎµ kN:",
    btnCheck: "âœ“ Î•Î›Î•Î“Î§ÎŸÎ£",
    btnHint: "ğŸ’¡ Î¥Ï€ÏŒÎ´ÎµÎ¹Î¾Î· (-5)",
    btnReset: "â†º Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬",
    lblPhysicsTitle: "ğŸ“š Î£Ï…Î½Î¸Î®ÎºÎµÏ‚ Î™ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚",
    
    // Load descriptions
    loadAmbulance: "ğŸš‘ Î‘ÏƒÎ¸ÎµÎ½Î¿Ï†ÏŒÏÎ¿",
    loadTruck: "ğŸšš Î¦Î¿ÏÏ„Î·Î³ÏŒ",
    loadCar: "ğŸš— Î‘Ï…Ï„Î¿ÎºÎ¯Î½Î·Ï„Î¿",
    loadPerson: "ğŸ§‘ Î†Ï„Î¿Î¼Î¿",
    loadEquipment: "ğŸ“¦ Î•Î¾Î¿Ï€Î»Î¹ÏƒÎ¼ÏŒÏ‚",
    loadBridge: "Î“Î­Ï†Ï…ÏÎ±",
    
    // Results
    resultCorrect: "âœ… Î£Î©Î£Î¤Î‘! Î— Î³Î­Ï†Ï…ÏÎ± Î±Î½Ï„Î­Ï‡ÎµÎ¹!",
    resultWrong: "âŒ Î›Î‘Î˜ÎŸÎ£! Î— Î³Î­Ï†Ï…ÏÎ± ÎºÎ±Ï„Î­ÏÏÎµÏ…ÏƒÎµ!",
    resultClose: "ÎšÎ¿Î½Ï„Î¬! Î£Ï†Î¬Î»Î¼Î±: {error}%",
    
    // Hints
    hint1: "ğŸ’¡ Î Î¬ÏÎµ ÏÎ¿Ï€Î­Ï‚ Ï‰Ï‚ Ï€ÏÎ¿Ï‚ Ï„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ A (Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ ÏƒÏ„Î®ÏÎ¹Î³Î¼Î±)",
    hint2: "ğŸ’¡ Î£Ï„_A = 0: R_BÂ·L = W_Î³Â·(L/2) + Î£(W_iÂ·x_i)",
    hint3: "ğŸ’¡ Î‘Ï€ÏŒ Î£F_y = 0: R_A = Î£Ï…Î½Î¿Î»Î¹ÎºÏŒ_Ï†Î¿ÏÏ„Î¯Î¿ - R_B",
    
    // End screen
    endWin: "ğŸ‰ Î‘Î ÎŸÎ£Î¤ÎŸÎ›Î— Î•Î Î™Î¤Î¥Î§Î—Î£!",
    endLose: "ğŸ˜¢ Î‘Î ÎŸÎ¤Î¥Î§Î™Î‘...",
    endPerfect: "ğŸ† Î¤Î•Î›Î•Î™Î‘ Î•ÎšÎ¤Î•Î›Î•Î£Î—!",
    medalGold: "Î§Î¡Î¥Î£ÎŸ ÎœÎ•Î¤Î‘Î›Î›Î™ÎŸ!",
    medalSilver: "Î‘Î£Î—ÎœÎ•ÎÎ™ÎŸ ÎœÎ•Î¤Î‘Î›Î›Î™ÎŸ!",
    medalBronze: "Î§Î‘Î›ÎšÎ™ÎÎŸ ÎœÎ•Î¤Î‘Î›Î›Î™ÎŸ!",
    statsLevels: "Î•Ï€Î¯Ï€ÎµÎ´Î±:",
    statsAttempts: "Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚:",
    statsHints: "Î¥Ï€Î¿Î´ÎµÎ¯Î¾ÎµÎ¹Ï‚:",
    statsAccuracy: "ÎœÎ­ÏƒÎ· Î±ÎºÏÎ¯Î²ÎµÎ¹Î±:",
    analysisTitle: "ğŸ“Š Î‘Î½Î¬Î»Ï…ÏƒÎ· Î¦Ï…ÏƒÎ¹ÎºÎ®Ï‚",
    btnRestart: "ğŸ”„ ÎÎ­Î± Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®",
    
    // Jokes
    jokes: [
      "ÎŸÎ¹ Î±ÏÏ‡Î±Î¯Î¿Î¹ Î¡Ï‰Î¼Î±Î¯Î¿Î¹ Ï„Î¿ Î­ÎºÎ±Î½Î±Î½ Ï‡Ï‰ÏÎ¯Ï‚ ÎºÎ¿Î¼Ï€Î¹Î¿Ï…Ï„ÎµÏÎ¬ÎºÎ¹! ğŸ›ï¸",
      "ÎŸ Î‘ÏÏ‡Î¹Î¼Î®Î´Î·Ï‚ Î¸Î± Î®Ï„Î±Î½ Ï€ÎµÏÎ®Ï†Î±Î½Î¿Ï‚... Î® Î¼Î®Ï€Ï‰Ï‚ ÏŒÏ‡Î¹; ğŸ¤”",
      "Î— Î³Î­Ï†Ï…ÏÎ± Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Tacoma, Î¼Î·Î½ Î±Î½Î·ÏƒÏ…Ï‡ÎµÎ¯Ï‚! ğŸ’¨",
      "Î‘ÎºÏŒÎ¼Î± ÎºÎ±Î¹ Î¿ Newton Î¸Î± Ï‡ÏÎµÎ¹Î±Î¶ÏŒÏ„Î±Î½ Î¼Î¹Î± Î´ÎµÏÏ„ÎµÏÎ· Ï€ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹Î±! ğŸ",
      "Î— ÏÎ¿Ï€Î® Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï„Î¯Ï€Î¿Ï„Î± Ï‡Ï‰ÏÎ¯Ï‚ Ï„Î¿Î½ Î²ÏÎ±Ï‡Î¯Î¿Î½Î±! ğŸ’ª"
    ],
    easterEgg981: "ÎˆÎ½Î± Ï„ÏŒÎ½Î¿ ÏƒÏ„Î· Î“Î·! g = 9.81 m/sÂ² ğŸŒ",
    collapseMsg: "ÎšÎ¡Î‘Îš! Î— Î³Î­Ï†Ï…ÏÎ± ÎºÎ±Ï„Î­ÏÏÎµÏ…ÏƒÎµ! ğŸ’¥"
  },
  
  en: {
    title: "Bridge Operation - Rigid Body Equilibrium",
    introTitle: "ğŸŒ‰ BRIDGE OPERATION",
    langTitle: "ğŸŒ Language",
    scenarioHdr: "ğŸš¨ The Scenario",
    scenarioBody: `<strong style="color: var(--warn);">EMERGENCY!</strong> The storm destroyed the river bridge!<br><br>
      ğŸš‘ The ambulance must cross to reach the village.<br>
      ğŸ—ï¸ The school rescue team is building a makeshift bridge.<br><br>
      <strong style="color: var(--accent);">Your mission:</strong> Calculate the support reactions so the bridge holds!<br>
      If your calculations are wrong... the bridge will collapse! ğŸ’¥`,
    levelHdr: "ğŸ“Š Difficulty Level",
    levels: [
      { name: "Level 1: One load at center", desc: "Easy - Symmetric case" },
      { name: "Level 2: Off-center load", desc: "Medium - Asymmetric loading" },
      { name: "Level 3: Two loads", desc: "Hard - Multiple loads" },
      { name: "Level 4: Moving vehicle", desc: "Challenge - Load changes position" },
      { name: "Level 5: Full mission", desc: "Expert - Ambulance + equipment" }
    ],
    howtoHdr: "ğŸ“– How to Play",
    howtoBody: `1. Look at the loads on the bridge and their positions<br>
      2. Use the <strong>equilibrium conditions</strong>:<br>
      &nbsp;&nbsp;&nbsp;â€¢ Î£F<sub>y</sub> = 0 (sum of vertical forces = 0)<br>
      &nbsp;&nbsp;&nbsp;â€¢ Î£Ï„ = 0 (sum of torques about any point = 0)<br>
      3. Calculate reactions R<sub>A</sub> and R<sub>B</sub><br>
      4. Enter the values and press "Check"<br>
      5. If correct, proceed to the next level!`,
    scoringHdr: "ğŸ… Scoring",
    scoringBody: `â€¢ <strong>70%</strong> from attempts (each mistake: -10 points)<br>
      â€¢ <strong>30%</strong> from accuracy (how close to correct value)<br>
      â€¢ ğŸ¥‡ Gold: error < 2% | ğŸ¥ˆ Silver: < 5% | ğŸ¥‰ Bronze: < 10%<br>
      â€¢ ğŸ’¡ Hints: -5 points each`,
    startBtn: "ğŸš§ START BUILDING!",
    schoolLine: "Physics - Rigid Body Mechanics",
    
    lblScoreTitle: "ğŸ¯ Progress",
    lblLevel: "Level:",
    lblAttempts: "Attempts:",
    lblScore: "Score:",
    lblTime: "Time:",
    lblBridgeTitle: "ğŸŒ‰ Bridge Data",
    lblBridgeLen: "Bridge length L:",
    lblBridgeWeight: "Bridge weight W_b:",
    lblLoads: "ğŸ“¦ Loads:",
    lblTotalLoad: "Total load:",
    lblInputTitle: "ğŸ“ Calculate the Reactions",
    lblInputHint: "Use equilibrium conditions: Î£F = 0 and Î£Ï„ = 0",
    lblRA: "R_A (Left support) in kN:",
    lblRB: "R_B (Right support) in kN:",
    btnCheck: "âœ“ CHECK",
    btnHint: "ğŸ’¡ Hint (-5)",
    btnReset: "â†º Reset",
    lblPhysicsTitle: "ğŸ“š Equilibrium Conditions",
    
    loadAmbulance: "ğŸš‘ Ambulance",
    loadTruck: "ğŸšš Truck",
    loadCar: "ğŸš— Car",
    loadPerson: "ğŸ§‘ Person",
    loadEquipment: "ğŸ“¦ Equipment",
    loadBridge: "Bridge",
    
    resultCorrect: "âœ… CORRECT! The bridge holds!",
    resultWrong: "âŒ WRONG! The bridge collapsed!",
    resultClose: "Close! Error: {error}%",
    
    hint1: "ğŸ’¡ Take moments about point A (left support)",
    hint2: "ğŸ’¡ Î£Ï„_A = 0: R_BÂ·L = W_bÂ·(L/2) + Î£(W_iÂ·x_i)",
    hint3: "ğŸ’¡ From Î£F_y = 0: R_A = Total_load - R_B",
    
    endWin: "ğŸ‰ MISSION SUCCESSFUL!",
    endLose: "ğŸ˜¢ MISSION FAILED...",
    endPerfect: "ğŸ† PERFECT EXECUTION!",
    medalGold: "GOLD MEDAL!",
    medalSilver: "SILVER MEDAL!",
    medalBronze: "BRONZE MEDAL!",
    statsLevels: "Levels:",
    statsAttempts: "Attempts:",
    statsHints: "Hints:",
    statsAccuracy: "Avg accuracy:",
    analysisTitle: "ğŸ“Š Physics Analysis",
    btnRestart: "ğŸ”„ New Mission",
    
    jokes: [
      "Ancient Romans did it without calculators! ğŸ›ï¸",
      "Archimedes would be proud... or would he? ğŸ¤”",
      "This bridge isn't Tacoma, don't worry! ğŸ’¨",
      "Even Newton needed a second try! ğŸ",
      "Torque is nothing without the lever arm! ğŸ’ª"
    ],
    easterEgg981: "One ton on Earth! g = 9.81 m/sÂ² ğŸŒ",
    collapseMsg: "CRACK! The bridge collapsed! ğŸ’¥"
  },
  
  it: {
    title: "Operazione Ponte - Equilibrio del Corpo Rigido",
    introTitle: "ğŸŒ‰ OPERAZIONE PONTE",
    langTitle: "ğŸŒ Lingua",
    scenarioHdr: "ğŸš¨ Lo Scenario",
    scenarioBody: `<strong style="color: var(--warn);">EMERGENZA!</strong> La tempesta ha distrutto il ponte sul fiume!<br><br>
      ğŸš‘ L'ambulanza deve passare per raggiungere il villaggio.<br>
      ğŸ—ï¸ La squadra di soccorso della scuola costruisce un ponte provvisorio.<br><br>
      <strong style="color: var(--accent);">La tua missione:</strong> Calcola le reazioni dei supporti affinchÃ© il ponte regga!<br>
      Se i calcoli sono sbagliati... il ponte crollerÃ ! ğŸ’¥`,
    levelHdr: "ğŸ“Š Livello di DifficoltÃ ",
    levels: [
      { name: "Livello 1: Un carico al centro", desc: "Facile - Caso simmetrico" },
      { name: "Livello 2: Carico decentrato", desc: "Medio - Carico asimmetrico" },
      { name: "Livello 3: Due carichi", desc: "Difficile - Carichi multipli" },
      { name: "Livello 4: Veicolo in movimento", desc: "Sfida - Il carico cambia posizione" },
      { name: "Livello 5: Missione completa", desc: "Esperto - Ambulanza + attrezzature" }
    ],
    howtoHdr: "ğŸ“– Come si Gioca",
    howtoBody: `1. Guarda i carichi sul ponte e le loro posizioni<br>
      2. Usa le <strong>condizioni di equilibrio</strong>:<br>
      &nbsp;&nbsp;&nbsp;â€¢ Î£F<sub>y</sub> = 0 (somma delle forze verticali = 0)<br>
      &nbsp;&nbsp;&nbsp;â€¢ Î£Ï„ = 0 (somma dei momenti = 0)<br>
      3. Calcola le reazioni R<sub>A</sub> e R<sub>B</sub><br>
      4. Inserisci i valori e premi "Verifica"<br>
      5. Se corretto, passa al livello successivo!`,
    scoringHdr: "ğŸ… Punteggio",
    scoringBody: `â€¢ <strong>70%</strong> dai tentativi (ogni errore: -10 punti)<br>
      â€¢ <strong>30%</strong> dalla precisione<br>
      â€¢ ğŸ¥‡ Oro: errore < 2% | ğŸ¥ˆ Argento: < 5% | ğŸ¥‰ Bronzo: < 10%<br>
      â€¢ ğŸ’¡ Suggerimenti: -5 punti ciascuno`,
    startBtn: "ğŸš§ INIZIA A COSTRUIRE!",
    schoolLine: "Fisica - Meccanica del Corpo Rigido",
    
    lblScoreTitle: "ğŸ¯ Progresso",
    lblLevel: "Livello:",
    lblAttempts: "Tentativi:",
    lblScore: "Punteggio:",
    lblTime: "Tempo:",
    lblBridgeTitle: "ğŸŒ‰ Dati del Ponte",
    lblBridgeLen: "Lunghezza ponte L:",
    lblBridgeWeight: "Peso ponte W_p:",
    lblLoads: "ğŸ“¦ Carichi:",
    lblTotalLoad: "Carico totale:",
    lblInputTitle: "ğŸ“ Calcola le Reazioni",
    lblInputHint: "Usa le condizioni di equilibrio: Î£F = 0 e Î£Ï„ = 0",
    lblRA: "R_A (Supporto sinistro) in kN:",
    lblRB: "R_B (Supporto destro) in kN:",
    btnCheck: "âœ“ VERIFICA",
    btnHint: "ğŸ’¡ Aiuto (-5)",
    btnReset: "â†º Reset",
    lblPhysicsTitle: "ğŸ“š Condizioni di Equilibrio",
    
    loadAmbulance: "ğŸš‘ Ambulanza",
    loadTruck: "ğŸšš Camion",
    loadCar: "ğŸš— Auto",
    loadPerson: "ğŸ§‘ Persona",
    loadEquipment: "ğŸ“¦ Attrezzature",
    loadBridge: "Ponte",
    
    resultCorrect: "âœ… CORRETTO! Il ponte regge!",
    resultWrong: "âŒ SBAGLIATO! Il ponte Ã¨ crollato!",
    resultClose: "Vicino! Errore: {error}%",
    
    hint1: "ğŸ’¡ Prendi i momenti rispetto al punto A (supporto sinistro)",
    hint2: "ğŸ’¡ Î£Ï„_A = 0: R_BÂ·L = W_pÂ·(L/2) + Î£(W_iÂ·x_i)",
    hint3: "ğŸ’¡ Da Î£F_y = 0: R_A = Carico_totale - R_B",
    
    endWin: "ğŸ‰ MISSIONE RIUSCITA!",
    endLose: "ğŸ˜¢ MISSIONE FALLITA...",
    endPerfect: "ğŸ† ESECUZIONE PERFETTA!",
    medalGold: "MEDAGLIA D'ORO!",
    medalSilver: "MEDAGLIA D'ARGENTO!",
    medalBronze: "MEDAGLIA DI BRONZO!",
    statsLevels: "Livelli:",
    statsAttempts: "Tentativi:",
    statsHints: "Aiuti:",
    statsAccuracy: "Precisione media:",
    analysisTitle: "ğŸ“Š Analisi Fisica",
    btnRestart: "ğŸ”„ Nuova Missione",
    
    jokes: [
      "Gli antichi Romani lo facevano senza calcolatrice! ğŸ›ï¸",
      "Archimede sarebbe orgoglioso... o no? ğŸ¤”",
      "Questo ponte non Ã¨ il Tacoma, tranquillo! ğŸ’¨",
      "Anche Newton avrebbe bisogno di un secondo tentativo! ğŸ",
      "Il momento non Ã¨ niente senza il braccio! ğŸ’ª"
    ],
    easterEgg981: "Una tonnellata sulla Terra! g = 9.81 m/sÂ² ğŸŒ",
    collapseMsg: "CRACK! Il ponte Ã¨ crollato! ğŸ’¥"
  }
};

/* ========================================
   GAME STATE & CONSTANTS
   ======================================== */
let currentLang = 'el';
let currentLevel = 0;
let selectedLevelIndex = 0;
let attempts = 0;
let hintsUsed = 0;
let score = 100;
let totalAccuracy = 0;
let levelsCompleted = 0;
let gameStarted = false;
let gameTime = 300; // 5 minutes
let timerInterval = null;

const BRIDGE_LENGTH = 10; // meters
const BRIDGE_WEIGHT = 5; // kN (weight of the bridge itself)
const TOLERANCE = 0.1; // kN tolerance for correct answer

// Level configurations
const LEVELS = [
  // Level 1: Single load at center
  {
    loads: [{ type: 'car', weight: 10, position: 5, emoji: 'ğŸš—' }],
    bridgeWeight: 5
  },
  // Level 2: Single load off-center
  {
    loads: [{ type: 'truck', weight: 15, position: 3, emoji: 'ğŸšš' }],
    bridgeWeight: 5
  },
  // Level 3: Two loads
  {
    loads: [
      { type: 'car', weight: 8, position: 2, emoji: 'ğŸš—' },
      { type: 'person', weight: 0.8, position: 7, emoji: 'ğŸ§‘' }
    ],
    bridgeWeight: 5
  },
  // Level 4: Ambulance
  {
    loads: [{ type: 'ambulance', weight: 12, position: 4, emoji: 'ğŸš‘' }],
    bridgeWeight: 6
  },
  // Level 5: Full mission
  {
    loads: [
      { type: 'ambulance', weight: 12, position: 6, emoji: 'ğŸš‘' },
      { type: 'equipment', weight: 3, position: 2, emoji: 'ğŸ“¦' }
    ],
    bridgeWeight: 6
  }
];

let currentLoads = [];
let currentBridgeWeight = BRIDGE_WEIGHT;
let correctRA = 0;
let correctRB = 0;

/* ========================================
   UTILITY FUNCTIONS
   ======================================== */
function qs(id) { return document.getElementById(id); }

function setLanguage(lang) {
  currentLang = lang;
  const t = I18N[lang];
  
  document.title = t.title;
  
  // Update all UI text
  qs('introTitle').textContent = t.introTitle;
  qs('langTitle').textContent = t.langTitle;
  qs('scenarioHdr').textContent = t.scenarioHdr;
  qs('scenarioBody').innerHTML = t.scenarioBody;
  qs('levelHdr').textContent = t.levelHdr;
  qs('howtoHdr').textContent = t.howtoHdr;
  qs('howtoBody').innerHTML = t.howtoBody;
  qs('scoringHdr').textContent = t.scoringHdr;
  qs('scoringBody').innerHTML = t.scoringBody;
  qs('startBtn').textContent = t.startBtn;
  qs('schoolLine').textContent = t.schoolLine;
  
  // HUD labels
  qs('lblScoreTitle').textContent = t.lblScoreTitle;
  qs('lblLevel').textContent = t.lblLevel;
  qs('lblAttempts').textContent = t.lblAttempts;
  qs('lblScore').textContent = t.lblScore;
  qs('lblTime').textContent = t.lblTime;
  qs('lblBridgeTitle').textContent = t.lblBridgeTitle;
  qs('lblBridgeLen').textContent = t.lblBridgeLen;
  qs('lblBridgeWeight').innerHTML = t.lblBridgeWeight;
  qs('lblLoads').textContent = t.lblLoads;
  qs('lblTotalLoad').textContent = t.lblTotalLoad;
  qs('lblInputTitle').textContent = t.lblInputTitle;
  qs('lblInputHint').textContent = t.lblInputHint;
  qs('lblRA').innerHTML = t.lblRA;
  qs('lblRB').innerHTML = t.lblRB;
  qs('btnCheck').textContent = t.btnCheck;
  qs('btnHint').textContent = t.btnHint;
  qs('btnReset').textContent = t.btnReset;
  qs('lblPhysicsTitle').textContent = t.lblPhysicsTitle;
  qs('btnRestart').textContent = t.btnRestart;
  
  // Update level selector
  updateLevelSelector();
  
  // Update language button states
  document.querySelectorAll('.lang-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.lang === lang);
  });
}

function updateLevelSelector() {
  const t = I18N[currentLang];
  const container = qs('levelSelector');
  container.innerHTML = '';
  
  t.levels.forEach((level, i) => {
    const div = document.createElement('label');
    div.className = 'level-option' + (i === selectedLevelIndex ? ' selected' : '');
    div.innerHTML = `
      <input type="radio" name="level" value="${i}" ${i === selectedLevelIndex ? 'checked' : ''}>
      <div class="level-label">
        <strong>${level.name}</strong>
        <span>${level.desc}</span>
      </div>
    `;
    div.addEventListener('click', () => {
      selectedLevelIndex = i;
      document.querySelectorAll('.level-option').forEach(el => el.classList.remove('selected'));
      div.classList.add('selected');
    });
    container.appendChild(div);
  });
}

/* ========================================
   PHYSICS CALCULATIONS
   ======================================== */
function calculateCorrectReactions() {
  // Total weight = bridge weight + all loads
  let totalWeight = currentBridgeWeight;
  let totalMomentAboutA = currentBridgeWeight * (BRIDGE_LENGTH / 2); // Bridge weight at center
  
  currentLoads.forEach(load => {
    totalWeight += load.weight;
    totalMomentAboutA += load.weight * load.position;
  });
  
  // Î£Ï„_A = 0: R_B * L = totalMomentAboutA
  correctRB = totalMomentAboutA / BRIDGE_LENGTH;
  
  // Î£F_y = 0: R_A + R_B = totalWeight
  correctRA = totalWeight - correctRB;
  
  return { RA: correctRA, RB: correctRB, totalWeight };
}

function checkAnswer() {
  const userRA = parseFloat(qs('inputRA').value) || 0;
  const userRB = parseFloat(qs('inputRB').value) || 0;
  
  const errorRA = Math.abs(userRA - correctRA);
  const errorRB = Math.abs(userRB - correctRB);
  const maxError = Math.max(errorRA, errorRB);
  const percentError = (maxError / Math.max(correctRA, correctRB)) * 100;
  
  attempts++;
  updateHUD();
  
  const t = I18N[currentLang];
  const resultBox = qs('resultBox');
  
  if (errorRA <= TOLERANCE && errorRB <= TOLERANCE) {
    // Correct!
    const accuracy = Math.max(0, 100 - percentError * 10);
    totalAccuracy += accuracy;
    levelsCompleted++;
    
    resultBox.innerHTML = `<div class="result-box correct">
      ${t.resultCorrect}<br>
      <small>R<sub>A</sub> = ${correctRA.toFixed(2)} kN, R<sub>B</sub> = ${correctRB.toFixed(2)} kN</small><br>
      <small>${t.jokes[Math.floor(Math.random() * t.jokes.length)]}</small>
    </div>`;
    
    playSound('success');
    animateBridgeSuccess();
    
    // Easter egg check
    if (Math.abs(currentLoads.reduce((sum, l) => sum + l.weight, 0) - 9.81) < 0.1) {
      setTimeout(() => alert(t.easterEgg981), 500);
    }
    
    // Move to next level after delay
    setTimeout(() => {
      if (currentLevel < LEVELS.length - 1) {
        currentLevel++;
        setupLevel(currentLevel);
      } else {
        endGame(true);
      }
    }, 2000);
    
  } else if (percentError < 20) {
    // Close but not quite
    score = Math.max(0, score - 5);
    resultBox.innerHTML = `<div class="result-box wrong">
      ${t.resultClose.replace('{error}', percentError.toFixed(1))}<br>
      <small>Î ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Î¾Î±Î½Î¬! ÎˆÎ»ÎµÎ³Î¾Îµ Ï„Î¿Ï…Ï‚ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿ÏÏ‚ ÏƒÎ¿Ï….</small>
    </div>`;
    playSound('wrong');
    animateBridgeShake();
    
  } else {
    // Wrong - bridge collapses!
    score = Math.max(0, score - 10);
    resultBox.innerHTML = `<div class="result-box wrong">
      ${t.resultWrong}<br>
      <small>R<sub>A</sub> ÏƒÏ‰ÏƒÏ„ÏŒ: ${correctRA.toFixed(2)} kN, R<sub>B</sub> ÏƒÏ‰ÏƒÏ„ÏŒ: ${correctRB.toFixed(2)} kN</small>
    </div>`;
    playSound('collapse');
    animateBridgeCollapse();
  }
  
  updateHUD();
}

/* ========================================
   GAME SETUP & FLOW
   ======================================== */
function setupLevel(levelIndex) {
  const level = LEVELS[levelIndex];
  currentLoads = JSON.parse(JSON.stringify(level.loads)); // Deep copy
  currentBridgeWeight = level.bridgeWeight;
  
  calculateCorrectReactions();
  
  // Clear inputs
  qs('inputRA').value = '';
  qs('inputRB').value = '';
  qs('resultBox').innerHTML = '';
  qs('hintBox').classList.remove('visible');
  qs('hintBox').innerHTML = '';
  
  updateHUD();
  updateLoadsDisplay();
  draw();
}

function updateHUD() {
  const t = I18N[currentLang];
  
  qs('levelDisp').textContent = `${currentLevel + 1}/${LEVELS.length}`;
  qs('attemptsDisp').textContent = attempts;
  qs('scoreDisp').textContent = Math.max(0, score - hintsUsed * 5);
  
  qs('bridgeLenDisp').textContent = `${BRIDGE_LENGTH.toFixed(1)} m`;
  qs('bridgeWeightDisp').textContent = `${currentBridgeWeight.toFixed(1)} kN`;
  
  const totalLoad = currentBridgeWeight + currentLoads.reduce((sum, l) => sum + l.weight, 0);
  qs('totalLoadDisp').textContent = `${totalLoad.toFixed(1)} kN`;
  
  // Format time
  const mins = Math.floor(gameTime / 60);
  const secs = gameTime % 60;
  qs('timeDisp').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
  
  // Urgent warning when low time
  if (gameTime < 60) {
    qs('hudScore').classList.add('urgent');
  }
}

function updateLoadsDisplay() {
  const t = I18N[currentLang];
  const container = qs('loadsList');
  container.innerHTML = '';
  
  currentLoads.forEach((load, i) => {
    const typeKey = 'load' + load.type.charAt(0).toUpperCase() + load.type.slice(1);
    const name = t[typeKey] || load.type;
    
    const div = document.createElement('div');
    div.className = 'load-item';
    div.innerHTML = `
      <span class="emoji">${load.emoji}</span>
      <span>${name}: <strong>${load.weight} kN</strong> @ x=${load.position} m</span>
    `;
    container.appendChild(div);
  });
}

function showHint() {
  const t = I18N[currentLang];
  const hintBox = qs('hintBox');
  
  hintsUsed++;
  const hintNum = Math.min(hintsUsed, 3);
  const hint = t[`hint${hintNum}`];
  
  hintBox.innerHTML += `<p>${hint}</p>`;
  hintBox.classList.add('visible');
  
  updateHUD();
  playSound('hint');
}

function resetLevel() {
  qs('inputRA').value = '';
  qs('inputRB').value = '';
  qs('resultBox').innerHTML = '';
  draw();
}

function startGame() {
  gameStarted = true;
  currentLevel = selectedLevelIndex;
  attempts = 0;
  hintsUsed = 0;
  score = 100;
  totalAccuracy = 0;
  levelsCompleted = 0;
  gameTime = 300;
  
  qs('introScreen').classList.add('hidden');
  
  setupLevel(currentLevel);
  
  // Start timer
  timerInterval = setInterval(() => {
    gameTime--;
    updateHUD();
    if (gameTime <= 0) {
      clearInterval(timerInterval);
      endGame(false);
    }
  }, 1000);
  
  draw();
}

function endGame(won) {
  clearInterval(timerInterval);
  gameStarted = false;
  
  const t = I18N[currentLang];
  const finalScore = Math.max(0, score - hintsUsed * 5);
  const avgAccuracy = levelsCompleted > 0 ? (totalAccuracy / levelsCompleted) : 0;
  
  let medal, medalText, titleText;
  
  if (won && avgAccuracy >= 95) {
    medal = 'ğŸ†';
    medalText = t.endPerfect;
    titleText = t.endPerfect;
  } else if (won && avgAccuracy >= 90) {
    medal = 'ğŸ¥‡';
    medalText = t.medalGold;
    titleText = t.endWin;
  } else if (won && avgAccuracy >= 80) {
    medal = 'ğŸ¥ˆ';
    medalText = t.medalSilver;
    titleText = t.endWin;
  } else if (won) {
    medal = 'ğŸ¥‰';
    medalText = t.medalBronze;
    titleText = t.endWin;
  } else {
    medal = 'ğŸ’”';
    medalText = '';
    titleText = t.endLose;
  }
  
  qs('endTitle').textContent = titleText;
  qs('endMedal').textContent = medal;
  qs('endMessage').innerHTML = `
    <p style="font-size: 20px; color: var(--gold);"><strong>${medalText}</strong></p>
    <div style="margin: 20px 0;">
      <span class="success-stat">${t.statsLevels} ${levelsCompleted}/${LEVELS.length}</span>
      <span class="success-stat">${t.statsAttempts} ${attempts}</span>
      <span class="success-stat">${t.statsHints} ${hintsUsed}</span>
      <span class="success-stat">${t.statsAccuracy} ${avgAccuracy.toFixed(1)}%</span>
    </div>
    <div class="modal-section">
      <h4>${t.analysisTitle}</h4>
      <p style="font-size: 12px;">
        ${t.lblScore}: <strong>${finalScore}/100</strong><br><br>
        Î¤ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± ÏƒÏ‰ÏƒÏ„Î® Î»ÏÏƒÎ·:<br>
        R<sub>A</sub> = ${correctRA.toFixed(2)} kN<br>
        R<sub>B</sub> = ${correctRB.toFixed(2)} kN
      </p>
    </div>
  `;
  
  qs('endScreen').classList.remove('hidden');
  
  if (won) {
    playSound('win');
  }
}

function restartGame() {
  qs('endScreen').classList.add('hidden');
  qs('introScreen').classList.remove('hidden');
}

/* ========================================
   CANVAS DRAWING
   ======================================== */
const canvas = qs('canvas');
const ctx = canvas.getContext('2d');

// Coordinate system
const CANVAS_W = 1200;
const CANVAS_H = 750;
const BRIDGE_Y = 400; // Y position of bridge
const BRIDGE_START_X = 150;
const BRIDGE_END_X = 1050;
const SCALE = (BRIDGE_END_X - BRIDGE_START_X) / BRIDGE_LENGTH; // pixels per meter

let bridgeAngle = 0; // For animations
let bridgeCollapsed = false;
let shakeOffset = 0;

function draw() {
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  
  drawBackground();
  drawWater();
  drawBanks();
  drawBridge();
  drawSupports();
  drawLoads();
  drawForceArrows();
  drawMeasurements();
}

function drawBackground() {
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, 400);
  skyGrad.addColorStop(0, '#1a3a5c');
  skyGrad.addColorStop(1, '#2c5f7f');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, CANVAS_W, 400);
  
  // Grid pattern (blueprint style)
  ctx.strokeStyle = 'rgba(78, 205, 196, 0.1)';
  ctx.lineWidth = 1;
  for (let x = 0; x < CANVAS_W; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, CANVAS_H);
    ctx.stroke();
  }
  for (let y = 0; y < CANVAS_H; y += 50) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(CANVAS_W, y);
    ctx.stroke();
  }
  
  // Rain effect
  ctx.strokeStyle = 'rgba(150, 200, 255, 0.3)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 100; i++) {
    const x = Math.random() * CANVAS_W;
    const y = Math.random() * 350;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - 5, y + 15);
    ctx.stroke();
  }
}

function drawWater() {
  // Animated water
  const waterY = 550;
  const waterGrad = ctx.createLinearGradient(0, waterY, 0, CANVAS_H);
  waterGrad.addColorStop(0, 'rgba(30, 100, 150, 0.9)');
  waterGrad.addColorStop(1, 'rgba(20, 60, 100, 0.95)');
  ctx.fillStyle = waterGrad;
  ctx.fillRect(0, waterY, CANVAS_W, CANVAS_H - waterY);
  
  // Water waves
  ctx.strokeStyle = 'rgba(100, 180, 220, 0.4)';
  ctx.lineWidth = 2;
  const time = Date.now() / 500;
  for (let y = waterY + 20; y < CANVAS_H; y += 30) {
    ctx.beginPath();
    for (let x = 0; x < CANVAS_W; x += 10) {
      const waveY = y + Math.sin(x / 50 + time) * 5;
      if (x === 0) ctx.moveTo(x, waveY);
      else ctx.lineTo(x, waveY);
    }
    ctx.stroke();
  }
}

function drawBanks() {
  // Left bank
  ctx.fillStyle = '#3d2817';
  ctx.beginPath();
  ctx.moveTo(0, 350);
  ctx.lineTo(130, 350);
  ctx.lineTo(130, CANVAS_H);
  ctx.lineTo(0, CANVAS_H);
  ctx.closePath();
  ctx.fill();
  
  // Grass on left
  ctx.fillStyle = '#2d5a27';
  ctx.fillRect(0, 340, 130, 20);
  
  // Right bank
  ctx.fillStyle = '#3d2817';
  ctx.beginPath();
  ctx.moveTo(1070, 350);
  ctx.lineTo(CANVAS_W, 350);
  ctx.lineTo(CANVAS_W, CANVAS_H);
  ctx.lineTo(1070, CANVAS_H);
  ctx.closePath();
  ctx.fill();
  
  // Grass on right
  ctx.fillStyle = '#2d5a27';
  ctx.fillRect(1070, 340, 130, 20);
}

function drawBridge() {
  ctx.save();
  
  const centerX = (BRIDGE_START_X + BRIDGE_END_X) / 2;
  const centerY = BRIDGE_Y;
  
  // Apply shake or collapse animation
  ctx.translate(centerX + shakeOffset, centerY);
  ctx.rotate(bridgeAngle);
  ctx.translate(-centerX, -centerY);
  
  // Main bridge beam
  const beamHeight = 25;
  ctx.fillStyle = '#8B4513';
  ctx.strokeStyle = '#5D3A1A';
  ctx.lineWidth = 3;
  
  ctx.fillRect(BRIDGE_START_X, BRIDGE_Y - beamHeight/2, BRIDGE_END_X - BRIDGE_START_X, beamHeight);
  ctx.strokeRect(BRIDGE_START_X, BRIDGE_Y - beamHeight/2, BRIDGE_END_X - BRIDGE_START_X, beamHeight);
  
  // Wood texture lines
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 1;
  for (let x = BRIDGE_START_X + 30; x < BRIDGE_END_X; x += 60) {
    ctx.beginPath();
    ctx.moveTo(x, BRIDGE_Y - beamHeight/2);
    ctx.lineTo(x, BRIDGE_Y + beamHeight/2);
    ctx.stroke();
  }
  
  // Bridge deck (planks)
  ctx.fillStyle = '#A0522D';
  ctx.fillRect(BRIDGE_START_X, BRIDGE_Y - beamHeight/2 - 8, BRIDGE_END_X - BRIDGE_START_X, 8);
  
  ctx.restore();
}

function drawSupports() {
  // Left support (A)
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.moveTo(BRIDGE_START_X - 15, BRIDGE_Y + 15);
  ctx.lineTo(BRIDGE_START_X + 15, BRIDGE_Y + 15);
  ctx.lineTo(BRIDGE_START_X, BRIDGE_Y + 60);
  ctx.closePath();
  ctx.fill();
  
  // Support base
  ctx.fillStyle = '#666';
  ctx.fillRect(BRIDGE_START_X - 25, BRIDGE_Y + 55, 50, 15);
  
  // Label A
  ctx.fillStyle = '#4ECDC4';
  ctx.font = 'bold 16px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('A', BRIDGE_START_X, BRIDGE_Y + 85);
  
  // Right support (B)
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.moveTo(BRIDGE_END_X - 15, BRIDGE_Y + 15);
  ctx.lineTo(BRIDGE_END_X + 15, BRIDGE_Y + 15);
  ctx.lineTo(BRIDGE_END_X, BRIDGE_Y + 60);
  ctx.closePath();
  ctx.fill();
  
  // Support base
  ctx.fillStyle = '#666';
  ctx.fillRect(BRIDGE_END_X - 25, BRIDGE_Y + 55, 50, 15);
  
  // Label B
  ctx.fillStyle = '#4ECDC4';
  ctx.fillText('B', BRIDGE_END_X, BRIDGE_Y + 85);
}

function drawLoads() {
  currentLoads.forEach(load => {
    const x = BRIDGE_START_X + load.position * SCALE;
    const y = BRIDGE_Y - 50;
    
    // Draw emoji
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(load.emoji, x, y);
    
    // Draw weight label
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`${load.weight} kN`, x, y + 20);
    
    // Draw position label
    ctx.fillStyle = '#4ECDC4';
    ctx.font = '11px Arial';
    ctx.fillText(`x=${load.position}m`, x, y + 34);
  });
  
  // Bridge weight indicator (at center)
  const centerX = (BRIDGE_START_X + BRIDGE_END_X) / 2;
  ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(`W_Î³ = ${currentBridgeWeight} kN`, centerX, BRIDGE_Y + 35);
}

function drawForceArrows() {
  // Draw reaction force arrows (pointing up)
  
  // R_A arrow
  drawArrow(BRIDGE_START_X, BRIDGE_Y + 100, BRIDGE_START_X, BRIDGE_Y + 20, '#2ecc71', 3);
  ctx.fillStyle = '#2ecc71';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('R_A', BRIDGE_START_X, BRIDGE_Y + 120);
  
  // R_B arrow
  drawArrow(BRIDGE_END_X, BRIDGE_Y + 100, BRIDGE_END_X, BRIDGE_Y + 20, '#2ecc71', 3);
  ctx.fillStyle = '#2ecc71';
  ctx.fillText('R_B', BRIDGE_END_X, BRIDGE_Y + 120);
  
  // Weight arrows (pointing down)
  currentLoads.forEach(load => {
    const x = BRIDGE_START_X + load.position * SCALE;
    drawArrow(x, BRIDGE_Y - 60, x, BRIDGE_Y - 25, '#FF6B6B', 2);
  });
  
  // Bridge weight arrow
  const centerX = (BRIDGE_START_X + BRIDGE_END_X) / 2;
  drawArrow(centerX, BRIDGE_Y + 20, centerX, BRIDGE_Y + 50, '#FF6B6B', 2);
}

function drawArrow(fromX, fromY, toX, toY, color, width) {
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = width;
  
  const headLen = 12;
  const angle = Math.atan2(toY - fromY, toX - fromX);
  
  // Line
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();
  
  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(toX, toY);
  ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI/6), toY - headLen * Math.sin(angle - Math.PI/6));
  ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI/6), toY - headLen * Math.sin(angle + Math.PI/6));
  ctx.closePath();
  ctx.fill();
}

function drawMeasurements() {
  // Length ruler
  ctx.strokeStyle = 'rgba(78, 205, 196, 0.5)';
  ctx.lineWidth = 1;
  
  const rulerY = BRIDGE_Y + 150;
  
  // Main line
  ctx.beginPath();
  ctx.moveTo(BRIDGE_START_X, rulerY);
  ctx.lineTo(BRIDGE_END_X, rulerY);
  ctx.stroke();
  
  // End caps
  ctx.beginPath();
  ctx.moveTo(BRIDGE_START_X, rulerY - 8);
  ctx.lineTo(BRIDGE_START_X, rulerY + 8);
  ctx.moveTo(BRIDGE_END_X, rulerY - 8);
  ctx.lineTo(BRIDGE_END_X, rulerY + 8);
  ctx.stroke();
  
  // Distance markers
  ctx.fillStyle = 'rgba(78, 205, 196, 0.7)';
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  for (let i = 0; i <= BRIDGE_LENGTH; i += 2) {
    const x = BRIDGE_START_X + i * SCALE;
    ctx.beginPath();
    ctx.moveTo(x, rulerY - 4);
    ctx.lineTo(x, rulerY + 4);
    ctx.stroke();
    ctx.fillText(`${i}m`, x, rulerY + 18);
  }
  
  // L label
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 14px Arial';
  ctx.fillText(`L = ${BRIDGE_LENGTH} m`, (BRIDGE_START_X + BRIDGE_END_X) / 2, rulerY - 12);
}

/* ========================================
   ANIMATIONS
   ======================================== */
function animateBridgeSuccess() {
  // Quick green flash
  const originalFill = ctx.fillStyle;
  ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
  ctx.fillRect(BRIDGE_START_X - 20, BRIDGE_Y - 80, BRIDGE_END_X - BRIDGE_START_X + 40, 160);
  setTimeout(() => draw(), 300);
}

function animateBridgeShake() {
  let shakeCount = 0;
  const shake = () => {
    shakeOffset = (shakeCount % 2 === 0 ? 5 : -5);
    draw();
    shakeCount++;
    if (shakeCount < 10) {
      setTimeout(shake, 50);
    } else {
      shakeOffset = 0;
      draw();
    }
  };
  shake();
}

function animateBridgeCollapse() {
  let angle = 0;
  const collapse = () => {
    angle += 0.05;
    bridgeAngle = angle;
    draw();
    if (angle < 0.5) {
      setTimeout(collapse, 30);
    } else {
      setTimeout(() => {
        bridgeAngle = 0;
        draw();
      }, 1000);
    }
  };
  collapse();
}

/* ========================================
   AUDIO
   ======================================== */
let audioCtx = null;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playSound(type) {
  try {
    initAudio();
    if (!audioCtx) return;
    
    const now = audioCtx.currentTime;
    
    if (type === 'success') {
      [523, 659, 784].forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.15, now + i * 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
        osc.start(now + i * 0.1);
        osc.stop(now + i * 0.1 + 0.3);
      });
    } else if (type === 'wrong') {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = 200;
      osc.type = 'sawtooth';
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      osc.start(now);
      osc.stop(now + 0.3);
    } else if (type === 'collapse') {
      // Low rumble
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.8, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (buffer.length * 0.2));
      }
      noise.buffer = buffer;
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 200;
      
      const gain = audioCtx.createGain();
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
      noise.start(now);
    } else if (type === 'hint') {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = 880;
      osc.type = 'sine';
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
    } else if (type === 'win') {
      [523, 659, 784, 1047].forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.15, now + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.4);
        osc.start(now + i * 0.15);
        osc.stop(now + i * 0.15 + 0.4);
      });
    }
  } catch (e) {
    // Audio not available
  }
}

/* ========================================
   EVENT LISTENERS
   ======================================== */
document.addEventListener('DOMContentLoaded', () => {
  // Language buttons
  document.querySelectorAll('.lang-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      setLanguage(btn.dataset.lang);
    });
  });
  
  // Start button
  qs('startBtn').addEventListener('click', () => {
    initAudio();
    startGame();
  });
  
  // Game buttons
  qs('btnCheck').addEventListener('click', checkAnswer);
  qs('btnHint').addEventListener('click', showHint);
  qs('btnReset').addEventListener('click', resetLevel);
  qs('btnRestart').addEventListener('click', restartGame);
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (!gameStarted) return;
    
    if (e.key === 'Enter') {
      e.preventDefault();
      checkAnswer();
    } else if (e.key === 'h' || e.key === 'H') {
      showHint();
    } else if (e.key === 'r' || e.key === 'R') {
      resetLevel();
    }
  });
  
  // Initialize
  setLanguage('el');
  updateLevelSelector();
  
  // Responsive container
  function resizeContainer() {
    const container = qs('game-container');
    const w = window.innerWidth;
    const h = window.innerHeight;
    const scale = Math.min(w / 1200, h / 750);
    
    if (w < 1200 || h < 750) {
      container.style.transform = `scale(${scale})`;
      container.style.transformOrigin = 'center center';
    } else {
      container.style.transform = '';
    }
  }
  
  window.addEventListener('resize', resizeContainer);
  resizeContainer();
  
  // Initial draw
  setupLevel(0);
});
</script>
</body>
</html>
