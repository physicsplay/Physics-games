<!DOCTYPE html>
<html lang="el">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>Î•Ï€Î¹Ï‡ÎµÎ¯ÏÎ·ÏƒÎ· Î•ÎºÏ„ÏŒÎ¾ÎµÏ…ÏƒÎ· ÎšÎ»ÏŒÎ¿Ï…Î½ - Physics Game</title>

<style>
:root {
  --bg: #0a0a1a;
  --panel: rgba(20, 25, 45, 0.92);
  --panel2: rgba(60, 20, 60, 0.92);
  --accent: #FF6B9D;
  --accent2: #4ECDC4;
  --gold: #FFD700;
  --warn: #FF6B6B;
  --muted: #a8b2c1;
  --spring: #7ED321;
}

* { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; width: 100%; background: var(--bg); overflow: hidden; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; color: #fff; }
body { display: flex; justify-content: center; align-items: center; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

#game-container {
  position: relative;
  width: 1200px;
  height: 700px;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 0 60px rgba(255, 107, 157, 0.15);
  background: linear-gradient(180deg, #0d0d20 0%, #1a1a35 100%);
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
}

/* HUD Panels */
.hud-panel {
  position: absolute;
  padding: 14px;
  border-radius: 12px;
  backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.08);
  pointer-events: none;
  font-size: 12px;
  line-height: 1.4;
}
h2 { font-size: 13px; color: var(--gold); margin-bottom: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 5px; }
h3 { font-size: 15px; color: var(--accent); margin-bottom: 10px; }

.hud-top-right { top: 10px; right: 10px; background: var(--panel); width: 280px; }
.hud-top-left { top: 10px; left: 10px; background: rgba(100, 60, 0, 0.88); width: 160px; border-color: rgba(255, 165, 0, 0.4); }
.hud-bottom-left { bottom: 10px; left: 10px; background: rgba(0, 80, 70, 0.88); width: 340px; border-color: rgba(78, 205, 196, 0.4); }
.hud-bottom-right { bottom: 10px; right: 10px; background: var(--panel2); width: 260px; border-color: rgba(255, 107, 157, 0.4); }

.stat-row { display: flex; justify-content: space-between; margin: 5px 0; font-size: 12px; }
.val { font-weight: 700; color: var(--accent2); white-space: nowrap; }
.val.gold { color: var(--gold); }
.val.warn { color: var(--warn); font-size: 14px; }
.val.attempt { color: #FFA500; font-size: 22px; }

.formula-box {
  background: rgba(255, 215, 0, 0.08);
  padding: 10px;
  border-radius: 8px;
  border-left: 3px solid var(--gold);
  margin-top: 8px;
  font-size: 11px;
}
.formula { font-family: "Times New Roman", Georgia, serif; font-size: 14px; color: #fff; margin: 4px 0; }
.hint { color: var(--accent2); font-size: 10px; margin-top: 6px; }

/* Screens */
.screen {
  position: absolute; inset: 0;
  background: rgba(8, 8, 18, 0.97);
  display: flex; justify-content: center; align-items: center;
  z-index: 9999;
  transition: opacity 0.4s;
  pointer-events: auto;
  overflow-y: auto;
}
.screen.hidden { opacity: 0; pointer-events: none; }

.modal {
  width: min(720px, calc(100vw - 24px));
  max-height: min(92vh, 780px);
  overflow: auto;
  text-align: center;
  padding: 28px;
  background: linear-gradient(145deg, #1a1a2e, #252545);
  border: 2px solid var(--accent);
  border-radius: 20px;
  box-shadow: 0 0 50px rgba(255, 107, 157, 0.15);
}
.modal h1 { color: var(--accent); font-size: 28px; margin-bottom: 14px; }
.modal p { margin-bottom: 10px; color: #d1d1d1; font-size: 14px; line-height: 1.6; }

.modal-section {
  background: rgba(255, 255, 255, 0.04);
  padding: 16px;
  border-radius: 14px;
  margin: 14px 0;
  text-align: left;
}
.modal-section h4 { color: var(--gold); margin-bottom: 10px; font-size: 14px; }

.lang-selector {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin: 16px 0;
}
.lang-btn {
  background: rgba(255, 255, 255, 0.06);
  border: 2px solid transparent;
  padding: 8px 16px;
  border-radius: 10px;
  font-size: 20px;
  cursor: pointer;
  transition: 0.2s;
}
.lang-btn:hover { background: rgba(255, 255, 255, 0.12); }
.lang-btn.selected { border-color: var(--gold); background: rgba(255, 215, 0, 0.12); }

.difficulty-selector { display: flex; flex-direction: column; gap: 10px; margin: 12px 0; }
.difficulty-option {
  display: flex; align-items: center; gap: 12px;
  padding: 14px 16px;
  background: rgba(255, 255, 255, 0.04);
  border: 2px solid transparent;
  border-radius: 14px;
  cursor: pointer;
  transition: 0.2s;
  pointer-events: auto;
}
.difficulty-option:hover { background: rgba(255, 255, 255, 0.08); border-color: rgba(255, 215, 0, 0.25); }
.difficulty-option.selected { background: rgba(255, 215, 0, 0.12); border-color: var(--gold); }
.difficulty-option input { transform: scale(1.3); accent-color: var(--gold); }
.difficulty-label { flex: 1; text-align: left; }
.difficulty-label strong { color: var(--gold); display: block; margin-bottom: 3px; font-size: 14px; }
.difficulty-label span { font-size: 11px; color: #a0a0a0; }

.keys {
  display: inline-block;
  background: #2a2a3a;
  padding: 3px 8px;
  border-radius: 5px;
  border-bottom: 2px solid #111;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  color: #fff;
  font-size: 11px;
}

/* Buttons */
button {
  background: linear-gradient(135deg, var(--accent), #d94a7b);
  color: #fff;
  border: none;
  padding: 14px 32px;
  border-radius: 999px;
  font-size: 16px;
  font-weight: 800;
  cursor: pointer;
  margin-top: 14px;
  transition: transform 0.15s, box-shadow 0.15s;
  pointer-events: auto;
  touch-action: manipulation;
}
button:hover { transform: scale(1.04); box-shadow: 0 0 25px rgba(255, 107, 157, 0.4); }
button.secondary {
  background: linear-gradient(135deg, var(--accent2), #3ba89e);
}

/* Control Panel */
.control-panel {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--panel);
  padding: 16px;
  border-radius: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  width: 200px;
  pointer-events: auto;
  z-index: 50;
}
.control-panel h3 { font-size: 13px; color: var(--gold); margin-bottom: 12px; text-align: center; }

.slider-group { margin: 12px 0; }
.slider-group label { display: block; font-size: 11px; color: var(--muted); margin-bottom: 6px; }
.slider-group input[type="range"] { width: 100%; accent-color: var(--accent); }
.slider-value { text-align: center; font-size: 14px; font-weight: 700; color: var(--accent2); margin-top: 4px; }

.action-btn {
  width: 100%;
  padding: 12px;
  margin-top: 10px;
  font-size: 14px;
  border-radius: 10px;
}
.action-btn.launch { background: linear-gradient(135deg, #7ED321, #5cb318); }
.action-btn.slow { background: linear-gradient(135deg, #3498db, #2980b9); }
.action-btn.slow.active { background: linear-gradient(135deg, #e74c3c, #c0392b); }
.action-btn.reset { background: linear-gradient(135deg, #666, #444); margin-top: 8px; }
.action-btn.hint-btn { background: linear-gradient(135deg, #9b59b6, #8e44ad); margin-top: 8px; font-size: 12px; }

/* Pause Panel */
.hud-pause {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: min(450px, calc(100vw - 30px));
  background: rgba(0, 80, 60, 0.96);
  text-align: center;
  padding: 20px;
  border: 2px solid var(--accent2);
  border-radius: 16px;
  pointer-events: auto;
  z-index: 70;
}
.hud-pause.hidden { display: none; }
.pause-info { font-size: 13px; color: #e7e7e7; line-height: 1.65; }

/* Medal */
.medal {
  font-size: 80px;
  margin: 18px 0;
  text-shadow: 0 0 35px rgba(255, 215, 0, 0.4);
}
.medal-gold { color: var(--gold); }
.medal-silver { color: #C0C0C0; }
.medal-bronze { color: #CD7F32; }

.success-stat {
  display: inline-block;
  background: rgba(78, 205, 196, 0.15);
  padding: 7px 16px;
  border-radius: 999px;
  margin: 5px 4px;
  font-size: 13px;
}

/* Mobile Controls */
#mobileControls {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: 12px;
  display: none;
  gap: 10px;
  z-index: 80;
  pointer-events: auto;
}
.mobile-btn {
  padding: 12px 20px;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 700;
}

/* Responsive */
@media (max-width: 1250px) {
  #game-container { width: 100vw; height: 100vh; border-radius: 0; }
  .hud-panel { font-size: 11px; padding: 10px; }
  .hud-top-right { width: 240px; }
  .hud-bottom-left { width: 280px; }
  .hud-bottom-right { width: 220px; }
  .control-panel { width: 170px; padding: 12px; }
}

@media (max-width: 768px) {
  .hud-top-right, .hud-bottom-right { display: none; }
  .hud-bottom-left { 
    width: calc(50vw - 15px); 
    left: 10px; 
    bottom: 75px;
    font-size: 10px;
    padding: 8px;
  }
  .hud-bottom-left .formula-box { display: none; }
  .hud-top-left { width: 120px; font-size: 10px; padding: 8px; }
  .control-panel { 
    right: 10px; 
    width: calc(45vw - 15px);
    max-width: 180px;
    padding: 10px;
    top: auto;
    bottom: 75px;
    transform: none;
  }
  .control-panel h3 { font-size: 11px; margin-bottom: 8px; }
  .slider-group label { font-size: 10px; }
  .slider-value { font-size: 12px; }
  .action-btn { padding: 10px; font-size: 12px; }
  #mobileControls { display: flex; }
  .modal { padding: 18px; }
  .modal h1 { font-size: 22px; }
}

@media (max-width: 480px) {
  .hud-bottom-left { 
    width: calc(100vw - 20px);
    bottom: 130px;
    left: 10px;
  }
  .control-panel {
    width: calc(100vw - 20px);
    right: 10px;
    bottom: 65px;
    max-width: none;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }
  .control-panel h3 { width: 100%; margin-bottom: 4px; }
  .slider-group { flex: 1; min-width: 120px; margin: 0; }
  .action-btn { flex: 1; min-width: 80px; margin: 0; }
}

/* Easter egg animation */
@keyframes rainbow {
  0% { filter: hue-rotate(0deg); }
  100% { filter: hue-rotate(360deg); }
}
.rainbow { animation: rainbow 2s linear infinite; }

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}
.bounce { animation: bounce 0.5s ease-in-out infinite; }
</style>
</head>
<body>

<div id="game-container">
  <canvas id="gameCanvas"></canvas>
  
  <!-- HUD: Attempts -->
  <div class="hud-panel hud-top-left" id="hudAttempts">
    <h2 id="lblAttempts">Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚</h2>
    <div class="stat-row">
      <span id="lblAttemptNum">Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚:</span>
      <span class="val attempt" id="attemptCount">0</span>
    </div>
    <div class="stat-row">
      <span id="lblHints">Î¥Ï€Î¿Î´ÎµÎ¯Î¾ÎµÎ¹Ï‚:</span>
      <span class="val" id="hintsUsed">0</span>
    </div>
  </div>
  
  <!-- HUD: Physics Panel -->
  <div class="hud-panel hud-bottom-left" id="hudPhysics">
    <h2 id="lblPhysics">ğŸ“ Î¦Ï…ÏƒÎ¹ÎºÎ® Î‘Î½Î¬Î»Ï…ÏƒÎ·</h2>
    <div class="stat-row">
      <span>Ï‰ = âˆš(2k/m):</span>
      <span class="val" id="dispOmega">10 rad/s</span>
    </div>
    <div class="stat-row">
      <span id="lblPeriod">Î ÎµÏÎ¯Î¿Î´Î¿Ï‚ T:</span>
      <span class="val" id="dispPeriod">0.628 s</span>
    </div>
    <div class="stat-row">
      <span id="lblAmplitude">Î Î»Î¬Ï„Î¿Ï‚ Aâ‚€:</span>
      <span class="val" id="dispAmplitude">0.50 m</span>
    </div>
    <div class="stat-row">
      <span id="lblVelocity">Î¤Î±Ï‡ÏÏ„Î·Ï„Î± v:</span>
      <span class="val gold" id="dispVelocity">0.00 m/s</span>
    </div>
    <div class="stat-row">
      <span id="lblAccel">Î•Ï€Î¹Ï„Î¬Ï‡Ï…Î½ÏƒÎ· a:</span>
      <span class="val" id="dispAccel">0.00 m/sÂ²</span>
    </div>
    <div class="formula-box">
      <div class="formula">x = AÂ·cos(Ï‰t + Ï†)</div>
      <div class="formula">v = -AÏ‰Â·sin(Ï‰t + Ï†)</div>
      <div class="hint" id="hintDetach">ğŸ’¡ Î‘Ï€Î¿ÎºÏŒÎ»Î»Î·ÏƒÎ·: a = -g (ÏƒÏ„Î· Î¸.Ï†.Î¼.)</div>
    </div>
  </div>
  
  <!-- HUD: Target Info -->
  <div class="hud-panel hud-bottom-right" id="hudTarget">
    <h2>ğŸ¯ Î£Ï„ÏŒÏ‡Î¿Ï‚</h2>
    <div class="stat-row">
      <span id="lblTargetHeight">ÎÏˆÎ¿Ï‚ ÏƒÏ„ÏŒÏ‡Î¿Ï…:</span>
      <span class="val gold" id="targetHeightDisp">0.30 m</span>
    </div>
    <div class="stat-row">
      <span id="lblBallMass">ÎœÎ¬Î¶Î± Î²ÏŒÎ»Î¿Ï… mâ‚ƒ:</span>
      <span class="val" id="ballMassDisp">0.40 kg</span>
    </div>
    <div class="stat-row">
      <span id="lblDiskMass">ÎœÎ¬Î¶Î± (mâ‚+mâ‚‚):</span>
      <span class="val" id="diskMassDisp">0.20 kg</span>
    </div>
    <div class="formula-box">
      <div class="formula" style="font-size:12px;">u'â‚ = [(mâ‚+mâ‚‚)-mâ‚ƒ]/[(mâ‚+mâ‚‚)+mâ‚ƒ]Â·uâ‚€</div>
      <div class="hint" id="hintCollision">Î•Î»Î±ÏƒÏ„Î¹ÎºÎ® ÎºÏÎ¿ÏÏƒÎ·!</div>
    </div>
  </div>
  
  <!-- HUD: Formulas -->
  <div class="hud-panel hud-top-right" id="hudFormulas">
    <h2>ğŸ“š Î¤ÏÏ€Î¿Î¹</h2>
    <div class="formula-box" style="margin-top:0;">
      <div class="formula">k_Î¿Î» = 2k</div>
      <div class="formula">Ï‰ = âˆš(k_Î¿Î»/m_Î¿Î»)</div>
      <div class="formula">Î¸.Î¹.: 2kÂ·d = mÂ·g</div>
    </div>
    <div class="formula-box">
      <div class="formula">E = Â½k_Î¿Î»Â·AÂ²</div>
      <div class="formula">v_max = Ï‰Â·A</div>
    </div>
    <div class="hint" id="hintFormula">ğŸ“ Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚!</div>
  </div>
  
  <!-- Control Panel -->
  <div class="control-panel" id="controlPanel">
    <h3 id="lblControls">âš™ï¸ Î¡Ï…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚</h3>
    <div class="slider-group">
      <label id="lblInitDisp">Î‘ÏÏ‡Î¹ÎºÎ® Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· (cm)</label>
      <input type="range" id="sliderDisplacement" min="15" max="80" value="50" step="1">
      <div class="slider-value" id="dispValue">50 cm</div>
    </div>
    <button class="action-btn launch" id="btnLaunch">ğŸš€ Î•ÎšÎšÎ™ÎÎ—Î£Î—</button>
    <button class="action-btn slow" id="btnSlow">ğŸ¢ Î‘Î¡Î“Î— ÎšÎ™ÎÎ—Î£Î—</button>
    <button class="action-btn reset" id="btnReset">â†º Î•Î Î‘ÎÎ‘Î¦ÎŸÎ¡Î‘</button>
    <button class="action-btn hint-btn" id="btnHint">ğŸ’¡ Î¥Î ÎŸÎ”Î•Î™ÎÎ— (-5 Î²Î±Î¸Î¼Î¿Î¯)</button>
  </div>
  
  <!-- Pause Panel -->
  <div class="hud-panel hud-pause hidden" id="pausePanel">
    <h3 id="lblPaused">â¸ï¸ Î Î‘Î¥Î£Î—</h3>
    <div class="pause-info">
      <p id="pauseText1">Î§ÏÏŒÎ½Î¿Ï‚ Î³Î¹Î± Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿ÏÏ‚!</p>
      <p id="pauseText2">Î Î¬Ï„Î·ÏƒÎµ <span class="keys">P</span> Î³Î¹Î± ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±</p>
    </div>
    <button class="secondary" id="btnResume">â–¶ï¸ Î£Î¥ÎÎ•Î§Î•Î™Î‘</button>
  </div>
  
  <!-- Mobile Controls -->
  <div id="mobileControls">
    <button class="mobile-btn launch" id="mobileLaunch">ğŸš€</button>
    <button class="mobile-btn" id="mobilePause" style="background:#666;">â¸ï¸</button>
    <button class="mobile-btn" id="mobileReset" style="background:#444;">â†º</button>
  </div>
  
  <!-- Intro Screen -->
  <div class="screen" id="introScreen">
    <div class="modal">
      <h1>ğŸ¤¡ <span id="titleIntro">Î•Ï€Î¹Ï‡ÎµÎ¯ÏÎ·ÏƒÎ· Î•ÎºÏ„ÏŒÎ¾ÎµÏ…ÏƒÎ· ÎšÎ»ÏŒÎ¿Ï…Î½</span> ğŸš€</h1>
      
      <div class="lang-selector">
        <button class="lang-btn selected" data-lang="el">ğŸ‡¬ğŸ‡·</button>
        <button class="lang-btn" data-lang="en">ğŸ‡¬ğŸ‡§</button>
        <button class="lang-btn" data-lang="it">ğŸ‡®ğŸ‡¹</button>
      </div>
      
      <p id="storyText">ÎŸ ÎºÎ»ÏŒÎ¿Ï…Î½ Î•Ï…ÎºÎ»ÎµÎ¯Î´Î·Ï‚ ÎºÎ¬Î¸ÎµÏ„Î±Î¹ ÏƒÎµ Î­Î½Î±Î½ Ï„Î±Î»Î±Î½Ï„Ï‰Ï„Î® Î¼Îµ Î´ÏÎ¿ ÎµÎ»Î±Ï„Î®ÏÎ¹Î±. ÎŒÏ„Î±Î½ Ï€ÎµÏÎ¬ÏƒÎµÎ¹ Î±Ï€ÏŒ Ï„Î· Î¸Î­ÏƒÎ· Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚, Î¸Î± ÎºÏÎ¿Ï…ÏƒÏ„ÎµÎ¯ Î¼Îµ Î­Î½Î±Î½ Î²ÏŒÎ»Î¿ ÎºÎ±Î¹ Î¸Î± ÎµÎºÏ„Î¿Î¾ÎµÏ…Ï„ÎµÎ¯! Î’Î¿Î®Î¸Î·ÏƒÎ­ Ï„Î¿Î½ Î½Î± Ï€Î¹Î¬ÏƒÎµÎ¹ Ï„Î¿ Î¼Ï€Î±Î»ÏŒÎ½Î¹-ÏƒÏ„ÏŒÏ‡Î¿!</p>
      
      <div class="modal-section">
        <h4 id="lblMission">ğŸ¯ Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®</h4>
        <p id="missionText">Î¡ÏÎ¸Î¼Î¹ÏƒÎµ Ï„Î·Î½ Î±ÏÏ‡Î¹ÎºÎ® Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· ÏÏƒÏ„Îµ Ï„Î¿ ÎºÎµÏ†Î¬Î»Î¹ Ï„Î¿Ï… ÎºÎ»ÏŒÎ¿Ï…Î½, Î¼ÎµÏ„Î¬ Ï„Î·Î½ ÎºÏÎ¿ÏÏƒÎ· ÎºÎ±Î¹ Î±Ï€Î¿ÎºÏŒÎ»Î»Î·ÏƒÎ·, Î½Î± Ï†Ï„Î¬ÏƒÎµÎ¹ ÏƒÏ„Î¿ ÏÏˆÎ¿Ï‚ Ï„Î¿Ï… ÏƒÏ„ÏŒÏ‡Î¿Ï…!</p>
      </div>
      
      <div class="modal-section">
        <h4 id="lblDiffSelect">ğŸ“Š Î•Ï€Î¯Ï€ÎµÎ´Î¿ Î”Ï…ÏƒÎºÎ¿Î»Î¯Î±Ï‚</h4>
        <div class="difficulty-selector">
          <label class="difficulty-option selected" data-diff="easy">
            <input type="radio" name="diff" value="easy" checked>
            <div class="difficulty-label">
              <strong id="diffEasyTitle">ğŸŸ¢ Î•ÏÎºÎ¿Î»Î¿</strong>
              <span id="diffEasyDesc">Î’Î»Î­Ï€ÎµÎ¹Ï‚ Î¸Î­ÏƒÎ· Ï†.Î¼. & Î¸.Î¹., ÏƒÏ„ÏŒÏ‡Î¿Ï‚ ÎºÎ¿Î½Ï„Î¬</span>
            </div>
          </label>
          <label class="difficulty-option" data-diff="medium">
            <input type="radio" name="diff" value="medium">
            <div class="difficulty-label">
              <strong id="diffMedTitle">ğŸŸ¡ ÎœÎ­Ï„ÏÎ¹Î¿</strong>
              <span id="diffMedDesc">Î’Î»Î­Ï€ÎµÎ¹Ï‚ Î¼ÏŒÎ½Î¿ Î¸.Î¹., ÏƒÏ„ÏŒÏ‡Î¿Ï‚ Ï€Î¹Î¿ Î¼Î±ÎºÏÎ¹Î¬</span>
            </div>
          </label>
          <label class="difficulty-option" data-diff="hard">
            <input type="radio" name="diff" value="hard">
            <div class="difficulty-label">
              <strong id="diffHardTitle">ğŸ”´ Î”ÏÏƒÎºÎ¿Î»Î¿</strong>
              <span id="diffHardDesc">Î§Ï‰ÏÎ¯Ï‚ Î²Î¿Î·Î¸Î®Î¼Î±Ï„Î±, Ï…Ï€Î¿Î»ÏŒÎ³Î¹ÏƒÎµ Ï„Î± Ï€Î¬Î½Ï„Î±!</span>
            </div>
          </label>
        </div>
      </div>
      
      <div class="modal-section">
        <h4 id="lblScoring">ğŸ† Î’Î±Î¸Î¼Î¿Î»Î¿Î³Î¯Î±</h4>
        <p id="scoringText">
          ğŸ¥‡ Î§ÏÏ…ÏƒÏŒ: ÏƒÏ†Î¬Î»Î¼Î± &lt;5% | ğŸ¥ˆ Î‘ÏƒÎ·Î¼Î­Î½Î¹Î¿: &lt;10% | ğŸ¥‰ Î§Î¬Î»ÎºÎ¹Î½Î¿: &lt;20%<br>
          <small id="scoringNote">Î›Î¹Î³ÏŒÏ„ÎµÏÎµÏ‚ Ï€ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚ + Î±ÎºÏÎ¯Î²ÎµÎ¹Î± = ÎºÎ±Î»ÏÏ„ÎµÏÎ¿ ÏƒÎºÎ¿Ï!</small>
        </p>
      </div>
      
      <div class="modal-section">
        <h4 id="lblControls2">ğŸ® Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚</h4>
        <p id="controlsText">
          <span class="keys">P</span> Î Î±ÏÏƒÎ· | 
          <span class="keys">R</span> Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬ | 
          <span class="keys">H</span> Î¥Ï€ÏŒÎ´ÎµÎ¹Î¾Î· |
          <span class="keys">SPACE</span> Î•ÎºÎºÎ¯Î½Î·ÏƒÎ·
        </p>
      </div>
      
      <button id="btnStart">ğŸ® Î•ÎÎ‘Î¡ÎÎ—</button>
      
      <p style="font-size:11px; color:#666; margin-top:12px;" id="credits">
        ğŸ“ 2Î¿ Î›ÏÎºÎµÎ¹Î¿ ÎœÎ¿ÏƒÏ‡Î¬Ï„Î¿Ï… - Î¦Ï…ÏƒÎ¹ÎºÎ® ÎšÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ·Ï‚
      </p>
    </div>
  </div>
  
  <!-- End Screen -->
  <div class="screen hidden" id="endScreen">
    <div class="modal">
      <h1 id="endTitle">Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±</h1>
      <div class="medal" id="endMedal">ğŸª</div>
      <div id="endMessage"></div>
      <button id="btnRetry">ğŸ”„ ÎÎ‘ÎÎ‘Î Î‘Î™ÎÎ•</button>
      <button class="secondary" id="btnMenu" style="margin-left:10px;">ğŸ“‹ ÎœÎ•ÎÎŸÎ¥</button>
    </div>
  </div>
</div>

<script>
/* ========================================
   INTERNATIONALIZATION
======================================== */
const I18N = {
  el: {
    title: "Î•Ï€Î¹Ï‡ÎµÎ¯ÏÎ·ÏƒÎ· Î•ÎºÏ„ÏŒÎ¾ÎµÏ…ÏƒÎ· ÎšÎ»ÏŒÎ¿Ï…Î½",
    story: "ÎŸ ÎºÎ»ÏŒÎ¿Ï…Î½ Î•Ï…ÎºÎ»ÎµÎ¯Î´Î·Ï‚ ÎºÎ¬Î¸ÎµÏ„Î±Î¹ ÏƒÎµ Î­Î½Î±Î½ Ï„Î±Î»Î±Î½Ï„Ï‰Ï„Î® Î¼Îµ Î´ÏÎ¿ ÎµÎ»Î±Ï„Î®ÏÎ¹Î±. ÎŒÏ„Î±Î½ Ï€ÎµÏÎ¬ÏƒÎµÎ¹ Î±Ï€ÏŒ Ï„Î· Î¸Î­ÏƒÎ· Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚, Î¸Î± ÎºÏÎ¿Ï…ÏƒÏ„ÎµÎ¯ Î¼Îµ Î­Î½Î±Î½ Î²ÏŒÎ»Î¿ ÎºÎ±Î¹ Î¸Î± ÎµÎºÏ„Î¿Î¾ÎµÏ…Ï„ÎµÎ¯! Î’Î¿Î®Î¸Î·ÏƒÎ­ Ï„Î¿Î½ Î½Î± Ï€Î¹Î¬ÏƒÎµÎ¹ Ï„Î¿ Î¼Ï€Î±Î»ÏŒÎ½Î¹-ÏƒÏ„ÏŒÏ‡Î¿!",
    mission: "ğŸ¯ Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®",
    missionText: "Î¡ÏÎ¸Î¼Î¹ÏƒÎµ Ï„Î·Î½ Î±ÏÏ‡Î¹ÎºÎ® Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· ÏÏƒÏ„Îµ Ï„Î¿ ÎºÎµÏ†Î¬Î»Î¹ Ï„Î¿Ï… ÎºÎ»ÏŒÎ¿Ï…Î½, Î¼ÎµÏ„Î¬ Ï„Î·Î½ ÎºÏÎ¿ÏÏƒÎ· ÎºÎ±Î¹ Î±Ï€Î¿ÎºÏŒÎ»Î»Î·ÏƒÎ·, Î½Î± Ï†Ï„Î¬ÏƒÎµÎ¹ ÏƒÏ„Î¿ ÏÏˆÎ¿Ï‚ Ï„Î¿Ï… ÏƒÏ„ÏŒÏ‡Î¿Ï…!",
    difficulty: "ğŸ“Š Î•Ï€Î¯Ï€ÎµÎ´Î¿ Î”Ï…ÏƒÎºÎ¿Î»Î¯Î±Ï‚",
    easy: "ğŸŸ¢ Î•ÏÎºÎ¿Î»Î¿",
    easyDesc: "Î’Î»Î­Ï€ÎµÎ¹Ï‚ Î¸Î­ÏƒÎ· Ï†.Î¼. & Î¸.Î¹., ÏƒÏ„ÏŒÏ‡Î¿Ï‚ ÎºÎ¿Î½Ï„Î¬",
    medium: "ğŸŸ¡ ÎœÎ­Ï„ÏÎ¹Î¿", 
    medDesc: "Î’Î»Î­Ï€ÎµÎ¹Ï‚ Î¼ÏŒÎ½Î¿ Î¸.Î¹., ÏƒÏ„ÏŒÏ‡Î¿Ï‚ Ï€Î¹Î¿ Î¼Î±ÎºÏÎ¹Î¬",
    hard: "ğŸ”´ Î”ÏÏƒÎºÎ¿Î»Î¿",
    hardDesc: "Î§Ï‰ÏÎ¯Ï‚ Î²Î¿Î·Î¸Î®Î¼Î±Ï„Î±, Ï…Ï€Î¿Î»ÏŒÎ³Î¹ÏƒÎµ Ï„Î± Ï€Î¬Î½Ï„Î±!",
    scoring: "ğŸ† Î’Î±Î¸Î¼Î¿Î»Î¿Î³Î¯Î±",
    scoringText: "ğŸ¥‡ Î§ÏÏ…ÏƒÏŒ: ÏƒÏ†Î¬Î»Î¼Î± <5% | ğŸ¥ˆ Î‘ÏƒÎ·Î¼Î­Î½Î¹Î¿: <10% | ğŸ¥‰ Î§Î¬Î»ÎºÎ¹Î½Î¿: <20%",
    scoringNote: "Î›Î¹Î³ÏŒÏ„ÎµÏÎµÏ‚ Ï€ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚ + Î±ÎºÏÎ¯Î²ÎµÎ¹Î± = ÎºÎ±Î»ÏÏ„ÎµÏÎ¿ ÏƒÎºÎ¿Ï!",
    controls: "ğŸ® Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚",
    controlsText: "P: Î Î±ÏÏƒÎ· | R: Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬ | H: Î¥Ï€ÏŒÎ´ÎµÎ¹Î¾Î· | SPACE: Î•ÎºÎºÎ¯Î½Î·ÏƒÎ·",
    start: "ğŸ® Î•ÎÎ‘Î¡ÎÎ—",
    attempts: "Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹ÎµÏ‚",
    attemptNum: "Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚:",
    hints: "Î¥Ï€Î¿Î´ÎµÎ¯Î¾ÎµÎ¹Ï‚:",
    physics: "ğŸ“ Î¦Ï…ÏƒÎ¹ÎºÎ® Î‘Î½Î¬Î»Ï…ÏƒÎ·",
    period: "Î ÎµÏÎ¯Î¿Î´Î¿Ï‚ T:",
    amplitude: "Î Î»Î¬Ï„Î¿Ï‚ Aâ‚€:",
    velocity: "Î¤Î±Ï‡ÏÏ„Î·Ï„Î± v:",
    accel: "Î•Ï€Î¹Ï„Î¬Ï‡Ï…Î½ÏƒÎ· a:",
    hintDetach: "ğŸ’¡ Î‘Ï€Î¿ÎºÏŒÎ»Î»Î·ÏƒÎ·: a = -g (ÏƒÏ„Î· Î¸.Ï†.Î¼.)",
    target: "ğŸ¯ Î£Ï„ÏŒÏ‡Î¿Ï‚",
    targetHeight: "ÎÏˆÎ¿Ï‚ ÏƒÏ„ÏŒÏ‡Î¿Ï…:",
    ballMass: "ÎœÎ¬Î¶Î± Î²ÏŒÎ»Î¿Ï… mâ‚ƒ:",
    diskMass: "ÎœÎ¬Î¶Î± (mâ‚+mâ‚‚):",
    hintCollision: "Î•Î»Î±ÏƒÏ„Î¹ÎºÎ® ÎºÏÎ¿ÏÏƒÎ·!",
    formulas: "ğŸ“š Î¤ÏÏ€Î¿Î¹",
    hintFormula: "ğŸ“ Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚!",
    settings: "âš™ï¸ Î¡Ï…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚",
    initDisp: "Î‘ÏÏ‡Î¹ÎºÎ® Î¼ÎµÏ„Î±Ï„ÏŒÏ€Î¹ÏƒÎ· (cm)",
    launch: "ğŸš€ Î•ÎšÎšÎ™ÎÎ—Î£Î—",
    reset: "â†º Î•Î Î‘ÎÎ‘Î¦ÎŸÎ¡Î‘",
    hintBtn: "ğŸ’¡ Î¥Î ÎŸÎ”Î•Î™ÎÎ— (-5 Î²Î±Î¸Î¼Î¿Î¯)",
    paused: "â¸ï¸ Î Î‘Î¥Î£Î—",
    pauseText1: "Î§ÏÏŒÎ½Î¿Ï‚ Î³Î¹Î± Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿ÏÏ‚!",
    pauseText2: "Î Î¬Ï„Î·ÏƒÎµ P Î³Î¹Î± ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±",
    resume: "â–¶ï¸ Î£Î¥ÎÎ•Î§Î•Î™Î‘",
    endSuccess: "ğŸ‰ Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±!",
    endFail: "ğŸ’” Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î±",
    endClose: "Î£Ï‡ÎµÎ´ÏŒÎ½!",
    medalGold: "ğŸ¥‡ Î§ÏÏ…ÏƒÏŒ ÎœÎµÏ„Î¬Î»Î»Î¹Î¿!",
    medalSilver: "ğŸ¥ˆ Î‘ÏƒÎ·Î¼Î­Î½Î¹Î¿ ÎœÎµÏ„Î¬Î»Î»Î¹Î¿!",
    medalBronze: "ğŸ¥‰ Î§Î¬Î»ÎºÎ¹Î½Î¿ ÎœÎµÏ„Î¬Î»Î»Î¹Î¿!",
    tryAgain: "Î ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Î¾Î±Î½Î¬!",
    retry: "ğŸ”„ ÎÎ‘ÎÎ‘Î Î‘Î™ÎÎ•",
    menu: "ğŸ“‹ ÎœÎ•ÎÎŸÎ¥",
    physicsAnalysis: "ğŸ“Š Î¦Ï…ÏƒÎ¹ÎºÎ® Î‘Î½Î¬Î»Ï…ÏƒÎ·",
    theoreticalHeight: "Î˜ÎµÏ‰ÏÎ·Ï„Î¹ÎºÏŒ Î¼Î­Î³Î¹ÏƒÏ„Î¿ ÏÏˆÎ¿Ï‚:",
    actualHeight: "ÎÏˆÎ¿Ï‚ Ï€Î¿Ï… Î­Ï†Ï„Î±ÏƒÎµÏ‚:",
    error: "Î£Ï†Î¬Î»Î¼Î±:",
    detachVelocity: "Î¤Î±Ï‡ÏÏ„Î·Ï„Î± Î±Ï€Î¿ÎºÏŒÎ»Î»Î·ÏƒÎ·Ï‚:",
    score: "Î¤ÎµÎ»Î¹ÎºÏŒ ÏƒÎºÎ¿Ï:",
    credits: "ğŸ“ 2Î¿ Î›ÏÎºÎµÎ¹Î¿ ÎœÎ¿ÏƒÏ‡Î¬Ï„Î¿Ï… - Î¦Ï…ÏƒÎ¹ÎºÎ® ÎšÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ·Ï‚",
    joke1: "ÎŸ ÎÎµÏÏ„Ï‰Î½Î±Ï‚ Î¸Î± Î®Ï„Î±Î½ Ï€ÎµÏÎ®Ï†Î±Î½Î¿Ï‚! ğŸ",
    joke2: "Î— Ï†Ï…ÏƒÎ¹ÎºÎ® Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î¼Î±Î³ÎµÎ¯Î±... ÎµÎ¯Î½Î±Î¹ ÎºÎ±Î»ÏÏ„ÎµÏÎ·! âœ¨",
    joke3: "Î‘ÎºÏŒÎ¼Î± ÎºÎ±Î¹ Î¿Î¹ ÎºÎ»ÏŒÎ¿Ï…Î½ ÏƒÎ­Î²Î¿Î½Ï„Î±Î¹ Ï„Î· Î´Î¹Î±Ï„Î®ÏÎ·ÏƒÎ· Ï„Î·Ï‚ Î¿ÏÎ¼Î®Ï‚! ğŸ¤¡",
    easter: "ğŸŒˆ ÎŸÎ¥Î¡Î‘ÎÎ™ÎŸ Î¤ÎŸÎÎŸ! Î’ÏÎ®ÎºÎµÏ‚ Ï„Î¿ Easter Egg! ğŸª",
    hintText1: "Î— Ï„Î±Ï‡ÏÏ„Î·Ï„Î± ÏƒÏ„Î· Î˜.Î™. ÎµÎ¯Î½Î±Î¹ v = Ï‰Â·A",
    hintText2: "ÎœÎµÏ„Î¬ Ï„Î·Î½ ÎºÏÎ¿ÏÏƒÎ·: u'â‚ = [(mâ‚+mâ‚‚)-mâ‚ƒ]/[(mâ‚+mâ‚‚)+mâ‚ƒ]Â·uâ‚€",
    hintText3: "Î‘Ï€Î¿ÎºÏŒÎ»Î»Î·ÏƒÎ· ÏƒÏ„Î· Î¸.Ï†.Î¼. Î¼Îµ v = Ï‰Â·âˆš(Aâ‚Â²-dÂ²)",
    slowMotion: "ğŸ¢ Î‘Î¡Î“Î— ÎšÎ™ÎÎ—Î£Î—",
    normalSpeed: "ğŸ‡ ÎšÎ‘ÎÎŸÎÎ™ÎšÎ—"
  },
  en: {
    title: "Operation Clown Launch",
    story: "Euclid the clown sits on an oscillator with two springs. When he passes through equilibrium, he'll collide with a ball and launch! Help him catch the target balloon!",
    mission: "ğŸ¯ Mission",
    missionText: "Adjust the initial displacement so the clown's head, after collision and detachment, reaches the target height!",
    difficulty: "ğŸ“Š Difficulty Level",
    easy: "ğŸŸ¢ Easy",
    easyDesc: "See natural length & equilibrium positions, close target",
    medium: "ğŸŸ¡ Medium",
    medDesc: "See only equilibrium, target farther away",
    hard: "ğŸ”´ Hard",
    hardDesc: "No guides, calculate everything!",
    scoring: "ğŸ† Scoring",
    scoringText: "ğŸ¥‡ Gold: error <5% | ğŸ¥ˆ Silver: <10% | ğŸ¥‰ Bronze: <20%",
    scoringNote: "Fewer attempts + accuracy = better score!",
    controls: "ğŸ® Controls",
    controlsText: "P: Pause | R: Reset | H: Hint | SPACE: Launch",
    start: "ğŸ® START",
    attempts: "Attempts",
    attemptNum: "Number:",
    hints: "Hints:",
    physics: "ğŸ“ Physics Analysis",
    period: "Period T:",
    amplitude: "Amplitude Aâ‚€:",
    velocity: "Velocity v:",
    accel: "Acceleration a:",
    hintDetach: "ğŸ’¡ Detachment: a = -g (at natural length)",
    target: "ğŸ¯ Target",
    targetHeight: "Target height:",
    ballMass: "Ball mass mâ‚ƒ:",
    diskMass: "Mass (mâ‚+mâ‚‚):",
    hintCollision: "Elastic collision!",
    formulas: "ğŸ“š Formulas",
    hintFormula: "ğŸ“ Use the formulas!",
    settings: "âš™ï¸ Settings",
    initDisp: "Initial displacement (cm)",
    launch: "ğŸš€ LAUNCH",
    reset: "â†º RESET",
    hintBtn: "ğŸ’¡ HINT (-5 points)",
    paused: "â¸ï¸ PAUSED",
    pauseText1: "Time for calculations!",
    pauseText2: "Press P to continue",
    resume: "â–¶ï¸ CONTINUE",
    endSuccess: "ğŸ‰ Success!",
    endFail: "ğŸ’” Failed",
    endClose: "Close!",
    medalGold: "ğŸ¥‡ Gold Medal!",
    medalSilver: "ğŸ¥ˆ Silver Medal!",
    medalBronze: "ğŸ¥‰ Bronze Medal!",
    tryAgain: "Try again!",
    retry: "ğŸ”„ RETRY",
    menu: "ğŸ“‹ MENU",
    physicsAnalysis: "ğŸ“Š Physics Analysis",
    theoreticalHeight: "Theoretical max height:",
    actualHeight: "Height reached:",
    error: "Error:",
    detachVelocity: "Detachment velocity:",
    score: "Final score:",
    credits: "ğŸ“ 2nd High School of Moschato - Physics",
    joke1: "Newton would be proud! ğŸ",
    joke2: "Physics isn't magic... it's better! âœ¨",
    joke3: "Even clowns respect conservation of momentum! ğŸ¤¡",
    easter: "ğŸŒˆ RAINBOW! You found the Easter Egg! ğŸª",
    hintText1: "Velocity at equilibrium is v = Ï‰Â·A",
    hintText2: "After collision: u'â‚ = [(mâ‚+mâ‚‚)-mâ‚ƒ]/[(mâ‚+mâ‚‚)+mâ‚ƒ]Â·uâ‚€",
    hintText3: "Detachment at natural length with v = Ï‰Â·âˆš(Aâ‚Â²-dÂ²)",
    slowMotion: "ğŸ¢ SLOW MOTION",
    normalSpeed: "ğŸ‡ NORMAL"
  },
  it: {
    title: "Operazione Lancio del Clown",
    story: "Euclide il clown siede su un oscillatore con due molle. Quando passa per l'equilibrio, colliderÃ  con una palla e si lancerÃ ! Aiutalo a prendere il palloncino bersaglio!",
    mission: "ğŸ¯ Missione",
    missionText: "Regola lo spostamento iniziale affinchÃ© la testa del clown, dopo la collisione e il distacco, raggiunga l'altezza del bersaglio!",
    difficulty: "ğŸ“Š Livello di DifficoltÃ ",
    easy: "ğŸŸ¢ Facile",
    easyDesc: "Vedi posizione naturale & equilibrio, bersaglio vicino",
    medium: "ğŸŸ¡ Medio",
    medDesc: "Vedi solo equilibrio, bersaglio piÃ¹ lontano",
    hard: "ğŸ”´ Difficile",
    hardDesc: "Senza guide, calcola tutto!",
    scoring: "ğŸ† Punteggio",
    scoringText: "ğŸ¥‡ Oro: errore <5% | ğŸ¥ˆ Argento: <10% | ğŸ¥‰ Bronzo: <20%",
    scoringNote: "Meno tentativi + precisione = punteggio migliore!",
    controls: "ğŸ® Controlli",
    controlsText: "P: Pausa | R: Reset | H: Suggerimento | SPAZIO: Lancio",
    start: "ğŸ® INIZIA",
    attempts: "Tentativi",
    attemptNum: "Numero:",
    hints: "Suggerimenti:",
    physics: "ğŸ“ Analisi Fisica",
    period: "Periodo T:",
    amplitude: "Ampiezza Aâ‚€:",
    velocity: "VelocitÃ  v:",
    accel: "Accelerazione a:",
    hintDetach: "ğŸ’¡ Distacco: a = -g (a lunghezza naturale)",
    target: "ğŸ¯ Bersaglio",
    targetHeight: "Altezza bersaglio:",
    ballMass: "Massa palla mâ‚ƒ:",
    diskMass: "Massa (mâ‚+mâ‚‚):",
    hintCollision: "Collisione elastica!",
    formulas: "ğŸ“š Formule",
    hintFormula: "ğŸ“ Usa le formule!",
    settings: "âš™ï¸ Impostazioni",
    initDisp: "Spostamento iniziale (cm)",
    launch: "ğŸš€ LANCIO",
    reset: "â†º RESET",
    hintBtn: "ğŸ’¡ SUGGERIMENTO (-5 punti)",
    paused: "â¸ï¸ PAUSA",
    pauseText1: "Tempo per i calcoli!",
    pauseText2: "Premi P per continuare",
    resume: "â–¶ï¸ CONTINUA",
    endSuccess: "ğŸ‰ Successo!",
    endFail: "ğŸ’” Fallito",
    endClose: "Quasi!",
    medalGold: "ğŸ¥‡ Medaglia d'Oro!",
    medalSilver: "ğŸ¥ˆ Medaglia d'Argento!",
    medalBronze: "ğŸ¥‰ Medaglia di Bronzo!",
    tryAgain: "Riprova!",
    retry: "ğŸ”„ RIPROVA",
    menu: "ğŸ“‹ MENU",
    physicsAnalysis: "ğŸ“Š Analisi Fisica",
    theoreticalHeight: "Altezza massima teorica:",
    actualHeight: "Altezza raggiunta:",
    error: "Errore:",
    detachVelocity: "VelocitÃ  di distacco:",
    score: "Punteggio finale:",
    credits: "ğŸ“ 2Â° Liceo di Moschato - Fisica",
    joke1: "Newton sarebbe orgoglioso! ğŸ",
    joke2: "La fisica non Ã¨ magia... Ã¨ meglio! âœ¨",
    joke3: "Anche i clown rispettano la conservazione della quantitÃ  di moto! ğŸ¤¡",
    easter: "ğŸŒˆ ARCOBALENO! Hai trovato l'Easter Egg! ğŸª",
    hintText1: "La velocitÃ  all'equilibrio Ã¨ v = Ï‰Â·A",
    hintText2: "Dopo la collisione: u'â‚ = [(mâ‚+mâ‚‚)-mâ‚ƒ]/[(mâ‚+mâ‚‚)+mâ‚ƒ]Â·uâ‚€",
    hintText3: "Distacco a lunghezza naturale con v = Ï‰Â·âˆš(Aâ‚Â²-dÂ²)",
    slowMotion: "ğŸ¢ RALLENTATORE",
    normalSpeed: "ğŸ‡ NORMALE"
  }
};

let currentLang = 'el';
const t = (key) => I18N[currentLang][key] || I18N.el[key] || key;

/* ========================================
   PHYSICS CONSTANTS
======================================== */
const GRAVITY = 9.81; // m/sÂ² (using 10 for simplified calculations as in the problem)
const G = 10; // Simplified gravity for calculations
const PPM = 350; // Pixels per meter (scaling)

// Physical setup from the problem
const M1 = 0.1; // kg - disk mass
const M2 = 0.1; // kg - clown head mass
const M_TOTAL = M1 + M2; // 0.2 kg
const D_EQUILIBRIUM = 0.1; // m - equilibrium position below natural length
const K_SPRING = (M_TOTAL * G) / (2 * D_EQUILIBRIUM); // k = 10 N/m per spring
const K_TOTAL = 2 * K_SPRING; // 20 N/m
const OMEGA = Math.sqrt(K_TOTAL / M_TOTAL); // 10 rad/s

/* ========================================
   GAME STATE
======================================== */
let state = {
  phase: 'menu', // menu, idle, oscillating, collision, detached, projectile, end
  difficulty: 'easy',
  attempts: 0,
  hintsUsed: 0,
  paused: false,
  slowMotion: false,
  timeScale: 1, // 1 = normal, 0.25 = slow
  t: 0,
  
  // Oscillator state
  amplitude: 0.5, // m (initial displacement from equilibrium)
  initialDisplacement: 0.5, // m
  position: 0, // current position relative to equilibrium (positive = up)
  velocity: 0,
  acceleration: 0,
  oscillatorPhase: Math.PI, // Start at bottom (x = -A)
  passedEquilibrium: false, // Track if we've passed equilibrium going UP
  
  // Ball (projectile that clown collides with)
  ballMass: 0.4, // kg
  ballPos: { x: 0, y: 0 },
  ballVel: 0,
  ballStartY: 0,
  ballVisible: true, // Always visible
  ballActive: false,
  
  // Disk continues oscillating after collision
  diskPos: 0,
  diskVel: 0,
  
  // Clown head after detachment
  clownDetached: false,
  clownPos: { x: 0, y: 0 },
  clownVel: 0,
  detachTime: 0,
  detachVelocity: 0,
  detachPosition: 0,
  
  // Collision occurred
  collisionOccurred: false,
  postCollisionVelocity: 0,
  postCollisionAmplitude: 0,
  
  // Target
  targetHeight: 0.3, // m above natural length position
  
  // Results
  maxHeightReached: 0,
  theoreticalMaxHeight: 0,
  
  // Visual positions (pixels)
  naturalLengthY: 200, // Y position of natural length on canvas
  equilibriumY: 235, // Y position of equilibrium
  diskVisualY: 0,
  
  // Trail for visualization
  trail: [],
  
  // Easter egg
  easterEggTriggered: false
};

/* ========================================
   DOM ELEMENTS
======================================== */
const qs = (id) => document.getElementById(id);
const canvas = qs('gameCanvas');
const ctx = canvas.getContext('2d');

/* ========================================
   DIFFICULTY SETTINGS
======================================== */
const DIFFICULTY_CONFIG = {
  easy: {
    showNaturalLength: true,
    showEquilibrium: true,
    targetRange: [0.15, 0.25], // m above natural length
    ballMass: 0.3 // lighter ball = head goes higher
  },
  medium: {
    showNaturalLength: false,
    showEquilibrium: true,
    targetRange: [0.20, 0.35],
    ballMass: 0.4
  },
  hard: {
    showNaturalLength: false,
    showEquilibrium: false,
    targetRange: [0.25, 0.45],
    ballMass: 0.5 // heavier ball = need more precise calculation
  }
};

/* ========================================
   INITIALIZATION
======================================== */
function init() {
  canvas.width = 1200;
  canvas.height = 700;
  
  setupEventListeners();
  updateUILanguage();
  
  // Initial draw
  draw();
}

function setupEventListeners() {
  // Language buttons
  document.querySelectorAll('.lang-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      currentLang = btn.dataset.lang;
      updateUILanguage();
    });
  });
  
  // Difficulty selection
  document.querySelectorAll('.difficulty-option').forEach(opt => {
    opt.addEventListener('click', () => {
      document.querySelectorAll('.difficulty-option').forEach(o => o.classList.remove('selected'));
      opt.classList.add('selected');
      opt.querySelector('input').checked = true;
      state.difficulty = opt.dataset.diff;
    });
  });
  
  // Start button
  qs('btnStart').addEventListener('click', startGame);
  
  // Displacement slider
  qs('sliderDisplacement').addEventListener('input', (e) => {
    const cm = parseInt(e.target.value);
    state.initialDisplacement = cm / 100;
    state.amplitude = cm / 100;
    qs('dispValue').textContent = `${cm} cm`;
    qs('dispAmplitude').textContent = `${(cm/100).toFixed(2)} m`;
    
    // Easter egg: exactly 42cm (answer to everything!)
    if (cm === 42 && !state.easterEggTriggered) {
      triggerEasterEgg();
    }
    
    if (state.phase === 'idle') {
      resetOscillator();
      draw();
    }
  });
  
  // Action buttons
  qs('btnLaunch').addEventListener('click', launchOscillator);
  qs('btnSlow').addEventListener('click', toggleSlowMotion);
  qs('btnReset').addEventListener('click', resetAttempt);
  qs('btnHint').addEventListener('click', showHint);
  qs('btnResume').addEventListener('click', togglePause);
  qs('btnRetry').addEventListener('click', resetAttempt);
  qs('btnMenu').addEventListener('click', backToMenu);
  
  // Mobile controls
  qs('mobileLaunch').addEventListener('click', launchOscillator);
  qs('mobilePause').addEventListener('click', togglePause);
  qs('mobileReset').addEventListener('click', resetAttempt);
  
  // Keyboard
  window.addEventListener('keydown', handleKeyboard);
}

function handleKeyboard(e) {
  if (state.phase === 'menu') return;
  
  switch(e.code) {
    case 'Space':
      e.preventDefault();
      if (state.phase === 'idle') launchOscillator();
      break;
    case 'KeyP':
      e.preventDefault();
      togglePause();
      break;
    case 'KeyR':
      e.preventDefault();
      resetAttempt();
      break;
    case 'KeyH':
      e.preventDefault();
      showHint();
      break;
  }
}

/* ========================================
   UI UPDATES
======================================== */
function updateUILanguage() {
  const lang = I18N[currentLang];
  
  // Update all text elements
  qs('titleIntro').textContent = lang.title;
  qs('storyText').textContent = lang.story;
  qs('lblMission').textContent = lang.mission;
  qs('missionText').textContent = lang.missionText;
  qs('lblDiffSelect').textContent = lang.difficulty;
  qs('diffEasyTitle').textContent = lang.easy;
  qs('diffEasyDesc').textContent = lang.easyDesc;
  qs('diffMedTitle').textContent = lang.medium;
  qs('diffMedDesc').textContent = lang.medDesc;
  qs('diffHardTitle').textContent = lang.hard;
  qs('diffHardDesc').textContent = lang.hardDesc;
  qs('lblScoring').textContent = lang.scoring;
  qs('scoringText').innerHTML = lang.scoringText + '<br><small>' + lang.scoringNote + '</small>';
  qs('lblControls2').textContent = lang.controls;
  qs('btnStart').textContent = lang.start;
  
  qs('lblAttempts').textContent = lang.attempts;
  qs('lblAttemptNum').textContent = lang.attemptNum;
  qs('lblHints').textContent = lang.hints;
  qs('lblPhysics').textContent = lang.physics;
  qs('lblPeriod').textContent = lang.period;
  qs('lblAmplitude').textContent = lang.amplitude;
  qs('lblVelocity').textContent = lang.velocity;
  qs('lblAccel').textContent = lang.accel;
  qs('hintDetach').textContent = lang.hintDetach;
  qs('lblTargetHeight').textContent = lang.targetHeight;
  qs('lblBallMass').textContent = lang.ballMass;
  qs('lblDiskMass').textContent = lang.diskMass;
  qs('hintCollision').textContent = lang.hintCollision;
  qs('hintFormula').textContent = lang.hintFormula;
  qs('lblControls').textContent = lang.settings;
  qs('lblInitDisp').textContent = lang.initDisp;
  qs('btnLaunch').textContent = lang.launch;
  qs('btnSlow').textContent = state.slowMotion ? lang.normalSpeed : lang.slowMotion;
  qs('btnReset').textContent = lang.reset;
  qs('btnHint').textContent = lang.hintBtn;
  qs('lblPaused').textContent = lang.paused;
  qs('pauseText1').textContent = lang.pauseText1;
  qs('btnResume').textContent = lang.resume;
  qs('btnRetry').textContent = lang.retry;
  qs('btnMenu').textContent = lang.menu;
  qs('credits').textContent = lang.credits;
}

function updateHUD() {
  qs('attemptCount').textContent = state.attempts;
  qs('hintsUsed').textContent = state.hintsUsed;
  qs('dispOmega').textContent = `${OMEGA.toFixed(1)} rad/s`;
  qs('dispPeriod').textContent = `${(2 * Math.PI / OMEGA).toFixed(3)} s`;
  qs('dispAmplitude').textContent = `${state.amplitude.toFixed(2)} m`;
  qs('dispVelocity').textContent = `${state.velocity.toFixed(2)} m/s`;
  qs('dispAccel').textContent = `${state.acceleration.toFixed(2)} m/sÂ²`;
  qs('targetHeightDisp').textContent = `${state.targetHeight.toFixed(2)} m`;
  qs('ballMassDisp').textContent = `${state.ballMass.toFixed(2)} kg`;
  qs('diskMassDisp').textContent = `${M_TOTAL.toFixed(2)} kg`;
}

/* ========================================
   GAME FLOW
======================================== */
function startGame() {
  const config = DIFFICULTY_CONFIG[state.difficulty];
  
  // Set ball mass based on difficulty
  state.ballMass = config.ballMass;
  
  // Set random target height within range
  const [minH, maxH] = config.targetRange;
  state.targetHeight = minH + Math.random() * (maxH - minH);
  
  // Reset state
  state.phase = 'idle';
  state.attempts = 0;
  state.hintsUsed = 0;
  state.easterEggTriggered = false;
  
  resetOscillator();
  
  qs('introScreen').classList.add('hidden');
  qs('endScreen').classList.add('hidden');
  
  updateHUD();
  requestAnimationFrame(gameLoop);
}

function resetOscillator() {
  // Initial position: x = -A (below equilibrium, springs compressed)
  state.position = -state.amplitude;
  state.velocity = 0;
  state.acceleration = -OMEGA * OMEGA * state.position;
  state.oscillatorPhase = Math.PI;
  state.t = 0;
  state.passedEquilibrium = false;
  
  // Reset collision state
  state.collisionOccurred = false;
  state.clownDetached = false;
  state.ballActive = false;
  state.ballVisible = true; // ALWAYS visible from start
  state.ballVel = 0;
  state.ballStartY = 0;
  state.maxHeightReached = -Infinity;
  
  state.diskPos = 0;
  state.diskVel = 0;
  state.trail = [];
  
  // Visual positions calculation
  const floorY = canvas.height - 50;
  const barHeight = 28;
  const minSpringHeight = 30; // Minimum visible spring when fully compressed
  const maxAmplitude = 0.8; // Maximum displacement in meters
  
  // Calculate equilibrium position
  state.equilibriumY = floorY - minSpringHeight - barHeight - maxAmplitude * PPM;
  
  // Natural length is d (0.1m) ABOVE equilibrium
  state.naturalLengthY = state.equilibriumY - D_EQUILIBRIUM * PPM;
  
  // Current disk position (starts at -A below equilibrium)
  state.diskVisualY = state.equilibriumY - state.position * PPM;
  
  // Ball position: AT EQUILIBRIUM, waiting for collision
  // Ball sits above where clown head will be when at equilibrium
  state.ballStartY = state.equilibriumY - barHeight/2 - 28 - 45;
  state.ballPos = {
    x: canvas.width / 2,
    y: state.ballStartY
  };
  
  console.log('Reset: A=' + state.amplitude.toFixed(2) + 'm, equilibriumY=' + state.equilibriumY);
}

function launchOscillator() {
  if (state.phase !== 'idle') return;
  
  state.phase = 'oscillating';
  state.attempts++;
  state.t = 0;
  state.passedEquilibrium = false;
  
  // Ball is visible but not active yet (will become active on collision)
  state.ballVisible = true;
  state.ballActive = false;
  
  updateHUD();
}

function resetAttempt() {
  console.log('=== Î•Î Î‘ÎÎ‘Î¦ÎŸÎ¡Î‘ ===');
  
  // Hide screens first
  qs('pausePanel').classList.add('hidden');
  qs('endScreen').classList.add('hidden');
  
  // Reset all state flags
  state.paused = false;
  state.t = 0;
  state.passedEquilibrium = false;
  state.collisionOccurred = false;
  state.collisionTime = 0;
  state.clownDetached = false;
  state.ballActive = false;
  state.ballVisible = true;
  state.ballVel = 0;
  state.postCollisionVelocity = 0;
  state.postCollisionAmplitude = 0;
  state.ballVelocityAfterCollision = 0;
  state.maxHeightReached = -Infinity;
  state.diskPos = 0;
  state.diskVel = 0;
  state.trail = [];
  
  // Reset oscillator positions
  resetOscillator();
  
  // Set phase AFTER reset
  state.phase = 'idle';
  
  // Update display
  updateHUD();
  
  // Restart game loop
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function backToMenu() {
  state.phase = 'menu';
  state.paused = false;
  qs('pausePanel').classList.add('hidden');
  qs('endScreen').classList.add('hidden');
  qs('introScreen').classList.remove('hidden');
}

function togglePause() {
  if (state.phase === 'menu' || state.phase === 'end') return;
  
  state.paused = !state.paused;
  qs('pausePanel').classList.toggle('hidden', !state.paused);
  
  if (!state.paused) {
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }
}

function toggleSlowMotion() {
  state.slowMotion = !state.slowMotion;
  state.timeScale = state.slowMotion ? 0.2 : 1;
  qs('btnSlow').classList.toggle('active', state.slowMotion);
  qs('btnSlow').textContent = state.slowMotion ? t('normalSpeed') : t('slowMotion');
}

function showHint() {
  if (state.phase === 'menu' || state.phase === 'end') return;
  
  state.hintsUsed++;
  updateHUD();
  
  // Show progressive hints
  const hints = [t('hintText1'), t('hintText2'), t('hintText3')];
  const hintIndex = Math.min(state.hintsUsed - 1, hints.length - 1);
  
  alert(`ğŸ’¡ ${t('hintBtn')}\n\n${hints[hintIndex]}`);
}

function triggerEasterEgg() {
  state.easterEggTriggered = true;
  
  // Rainbow effect on clown
  const modal = document.querySelector('.modal');
  modal.classList.add('rainbow');
  
  setTimeout(() => {
    alert(t('easter'));
    modal.classList.remove('rainbow');
  }, 500);
}

/* ========================================
   PHYSICS UPDATE
======================================== */
function updatePhysics(dt) {
  // Apply slow motion
  dt = dt * state.timeScale;
  
  if (state.phase !== 'oscillating') return;
  
  state.t += dt;
  
  if (!state.collisionOccurred) {
    // === BEFORE COLLISION ===
    // SHM: x(t) = -AÂ·cos(Ï‰t), starts at x = -A (bottom), moves UP toward x = 0
    const oldPos = state.position;
    state.position = -state.amplitude * Math.cos(OMEGA * state.t);
    state.velocity = state.amplitude * OMEGA * Math.sin(OMEGA * state.t);
    state.acceleration = -OMEGA * OMEGA * state.position;
    
    // Update disk visual position
    state.diskVisualY = state.equilibriumY - state.position * PPM;
    
    // COLLISION CHECK: First time crossing equilibrium (x=0) going UP
    // oldPos < 0 means we were below equilibrium
    // position >= 0 means we reached or passed equilibrium
    // velocity > 0 means moving UP
    if (oldPos < 0 && state.position >= 0 && state.velocity > 0) {
      console.log('>>> ÎšÎ¡ÎŸÎ¥Î£Î—! t=' + state.t.toFixed(3) + 's');
      state.position = 0; // Snap exactly to equilibrium
      state.diskVisualY = state.equilibriumY;
      performCollision();
    }
  } else {
    // === AFTER COLLISION ===
    const tAfterCollision = state.t - state.collisionTime;
    const animationDuration = 0.25; // Show animation for 0.25 seconds
    
    if (tAfterCollision < animationDuration) {
      // System goes DOWN with velocity u'â‚ (negative)
      const systemDisplacement = state.postCollisionVelocity * tAfterCollision;
      state.diskVisualY = state.equilibriumY - systemDisplacement * PPM;
      state.velocity = state.postCollisionVelocity;
      
      // Ball goes UP with velocity u'â‚ƒ (positive)
      const ballDisplacement = state.ballVelocityAfterCollision * tAfterCollision;
      state.ballPos.y = state.ballStartY - ballDisplacement * PPM;
      state.ballVel = state.ballVelocityAfterCollision;
    } else {
      // Animation done - freeze and show results
      endGame();
      return;
    }
  }
  
  // Trail for visualization
  if (!state.collisionOccurred) {
    if (state.trail.length === 0 || state.t - state.trail[state.trail.length - 1].time > 0.015) {
      state.trail.push({ x: canvas.width / 2, y: state.diskVisualY, time: state.t });
      if (state.trail.length > 200) state.trail.shift();
    }
  }
  
  updateHUD();
}

function performCollision() {
  state.collisionOccurred = true;
  state.collisionTime = state.t;
  
  // Elastic collision formulas
  // uâ‚€ = velocity of system before collision = Ï‰Â·A (moving UP at equilibrium)
  const u0 = OMEGA * state.amplitude; // Positive = upward
  
  // u'â‚ = [(mâ‚+mâ‚‚) - mâ‚ƒ] / [(mâ‚+mâ‚‚) + mâ‚ƒ] Â· uâ‚€
  // NEGATIVE = system moves DOWN after collision
  const massRatio = (M_TOTAL - state.ballMass) / (M_TOTAL + state.ballMass);
  state.postCollisionVelocity = massRatio * u0;
  
  // u'â‚ƒ = 2(mâ‚+mâ‚‚) / [(mâ‚+mâ‚‚) + mâ‚ƒ] Â· uâ‚€
  // POSITIVE = ball moves UP after collision
  state.ballVelocityAfterCollision = (2 * M_TOTAL) / (M_TOTAL + state.ballMass) * u0;
  
  // Ball becomes active (starts moving)
  state.ballActive = true;
  state.ballVel = state.ballVelocityAfterCollision;
  
  // Ball starting position is at equilibrium (where collision happened)
  const barHeight = 28;
  state.ballStartY = state.equilibriumY - barHeight/2 - 28 - 50;
  state.ballPos = {
    x: canvas.width / 2,
    y: state.ballStartY
  };
  
  // New amplitude for oscillator
  state.postCollisionAmplitude = Math.abs(state.postCollisionVelocity) / OMEGA;
  
  console.log(`=== ÎšÎ¡ÎŸÎ¥Î£Î— ===`);
  console.log(`Î ÏÎ¹Î½: uâ‚€ = ${u0.toFixed(2)} m/s (â†‘)`);
  console.log(`ÎœÎµÏ„Î¬ - Î£ÏÏƒÏ„Î·Î¼Î±: u'â‚ = ${state.postCollisionVelocity.toFixed(2)} m/s (â†“)`);
  console.log(`ÎœÎµÏ„Î¬ - Î’ÏŒÎ»Î¿Ï‚: u'â‚ƒ = ${state.ballVelocityAfterCollision.toFixed(2)} m/s (â†‘)`);
}

function performDetachment() {
  state.clownDetached = true;
  state.detachTime = state.t;
  state.detachPosition = D_EQUILIBRIUM; // Natural length position (d above equilibrium)
  
  // Velocity at detachment: v = Ï‰Â·âˆš(Aâ‚Â² - dÂ²)
  const A1squared = state.postCollisionAmplitude * state.postCollisionAmplitude;
  const dSquared = D_EQUILIBRIUM * D_EQUILIBRIUM;
  
  if (A1squared > dSquared) {
    state.detachVelocity = OMEGA * Math.sqrt(A1squared - dSquared);
  } else {
    state.detachVelocity = 0;
  }
  
  // Clown starts at natural length position (d above equilibrium)
  const barHeight = 28;
  state.clownPos = {
    x: canvas.width / 2,
    y: state.naturalLengthY - barHeight/2 - 28
  };
  
  // Calculate theoretical max height above natural length
  state.theoreticalMaxHeight = (state.detachVelocity * state.detachVelocity) / (2 * G);
  
  console.log(`=== DETACHMENT ===`);
  console.log(`Detach velocity: ${state.detachVelocity.toFixed(3)} m/s`);
  console.log(`Theoretical max height: ${state.theoreticalMaxHeight.toFixed(3)} m`);
}

function endGame() {
  state.phase = 'end';
  
  // Calculate values
  const u0 = OMEGA * state.amplitude;
  const u1_after = state.postCollisionVelocity;
  const u3_after = state.ballVelocityAfterCollision;
  
  // Show end screen with collision analysis
  qs('endTitle').textContent = 'ğŸ¯ ÎšÏÎ¿ÏÏƒÎ· ÎŸÎ»Î¿ÎºÎ»Î·ÏÏÎ¸Î·ÎºÎµ!';
  qs('endTitle').style.color = '#4ECDC4';
  qs('endMedal').textContent = 'ğŸ’¥';
  qs('endMedal').className = 'medal';
  
  qs('endMessage').innerHTML = `
    <div class="modal-section" style="text-align:left;">
      <h4>ğŸ“Š Î‘Î½Î¬Î»Ï…ÏƒÎ· ÎšÏÎ¿ÏÏƒÎ·Ï‚</h4>
      <p style="font-size:13px; margin:0; line-height:1.8;">
        <strong>Î ÏÎ¹Î½ Ï„Î·Î½ ÎºÏÎ¿ÏÏƒÎ·:</strong><br>
        â€¢ Î Î»Î¬Ï„Î¿Ï‚ Ï„Î±Î»Î¬Î½Ï„Ï‰ÏƒÎ·Ï‚ A = <span style="color:var(--gold);">${state.amplitude.toFixed(2)} m</span><br>
        â€¢ Î¤Î±Ï‡ÏÏ„Î·Ï„Î± ÏƒÏ„Î· Î˜.Î™.: uâ‚€ = Ï‰A = <span style="color:var(--gold);">${u0.toFixed(2)} m/s</span> (â†‘)<br><br>
        
        <strong>ÎœÎµÏ„Î¬ Ï„Î·Î½ ÎºÏÎ¿ÏÏƒÎ· (ÎµÎ»Î±ÏƒÏ„Î¹ÎºÎ®):</strong><br>
        â€¢ Î£ÏÏƒÏ„Î·Î¼Î± (mâ‚+mâ‚‚ = ${M_TOTAL} kg): u'â‚ = <span style="color:#FF6B6B;">${u1_after.toFixed(2)} m/s</span> (â†“)<br>
        â€¢ Î’ÏŒÎ»Î¿Ï‚ (mâ‚ƒ = ${state.ballMass} kg): u'â‚ƒ = <span style="color:#4ECDC4;">${u3_after.toFixed(2)} m/s</span> (â†‘)<br><br>
        
        <strong>Î¤ÏÏ€Î¿Î¹:</strong><br>
        <code style="background:#333;padding:2px 6px;border-radius:4px;">u'â‚ = [(mâ‚+mâ‚‚)-mâ‚ƒ]/[(mâ‚+mâ‚‚)+mâ‚ƒ] Ã— uâ‚€</code><br>
        <code style="background:#333;padding:2px 6px;border-radius:4px;">u'â‚ƒ = 2(mâ‚+mâ‚‚)/[(mâ‚+mâ‚‚)+mâ‚ƒ] Ã— uâ‚€</code>
      </p>
    </div>
    <p style="font-size:12px; color:#888; margin-top:10px;">
      Î Î±ÏÎ±Ï„Î®ÏÎ·ÏƒÎµ: ÎŸ Î²ÏŒÎ»Î¿Ï‚ (Î²Î±ÏÏÏ„ÎµÏÎ¿Ï‚) Ï€Î®ÏÎµ Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ· Ï„Î±Ï‡ÏÏ„Î·Ï„Î± Ï€ÏÎ¿Ï‚ Ï„Î± Ï€Î¬Î½Ï‰!
    </p>
  `;
  
  qs('endScreen').classList.remove('hidden');
}

/* ========================================
   RENDERING
======================================== */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Background gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  bgGrad.addColorStop(0, '#0d0d20');
  bgGrad.addColorStop(1, '#1a1a35');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw grid
  drawGrid();
  
  // Draw reference lines based on difficulty
  const config = DIFFICULTY_CONFIG[state.difficulty];
  
  // Natural length is ABOVE equilibrium (springs uncompressed)
  if (config.showNaturalLength) {
    drawReferenceLine(state.naturalLengthY, '#7ED321', 'Î¸.Ï†.Î¼.');
  }
  // Equilibrium is BELOW natural length (springs compressed by weight)
  if (config.showEquilibrium) {
    drawReferenceLine(state.equilibriumY, '#4ECDC4', 'Î˜.Î™.');
  }
  
  // Draw target
  drawTarget();
  
  // Draw spring system
  drawSpringSystem();
  
  // Draw ball
  if (state.ballActive) {
    drawBall();
  }
  
  // Draw detached clown
  if (state.clownDetached) {
    drawDetachedClown();
  }
  
  // Draw trail
  drawTrail();
  
  // Draw velocity vector
  if (state.phase === 'oscillating' && !state.clownDetached) {
    drawVelocityVector();
  }
  
  // Pause overlay
  if (state.paused) {
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function drawGrid() {
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  
  for (let x = 0; x < canvas.width; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += 50) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
}

function drawReferenceLine(y, color, label) {
  // Draw line on the RIGHT side of canvas to avoid overlap with Physics Analysis panel
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2 - 100, y);
  ctx.lineTo(canvas.width - 220, y);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Full label on the right side
  ctx.fillStyle = color;
  ctx.font = 'bold 12px system-ui';
  ctx.textAlign = 'right';
  
  // Translate short labels to full Greek
  let fullLabel = label;
  if (label === 'Î˜.Î™.') fullLabel = 'Î˜Î­ÏƒÎ· Î™ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±Ï‚';
  if (label === 'Î¸.Ï†.Î¼.') fullLabel = 'Î˜Î­ÏƒÎ· Î¦Ï…ÏƒÎ¹ÎºÎ¿Ï ÎœÎ®ÎºÎ¿Ï…Ï‚';
  
  ctx.fillText(fullLabel, canvas.width - 225, y - 5);
}

function drawTarget() {
  // Target is now just a reference height indicator (no balloon)
  const targetY = state.naturalLengthY - state.targetHeight * PPM;
  
  // Just a subtle line showing target height
  ctx.strokeStyle = 'rgba(255, 107, 157, 0.3)';
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 10]);
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2 - 60, targetY);
  ctx.lineTo(canvas.width / 2 + 60, targetY);
  ctx.stroke();
  ctx.setLineDash([]);
  
  ctx.fillStyle = 'rgba(255, 107, 157, 0.6)';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(`ÏƒÏ„ÏŒÏ‡Î¿Ï‚: ${state.targetHeight.toFixed(2)}m`, canvas.width / 2, targetY - 5);
}

function drawSpringSystem() {
  const centerX = canvas.width / 2;
  const diskY = state.diskVisualY;
  const springSpacing = 35;
  
  // === FLOOR (bottom) ===
  ctx.fillStyle = '#4a4a5a';
  ctx.fillRect(centerX - 100, canvas.height - 50, 200, 40);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  for (let i = -90; i <= 90; i += 12) {
    ctx.beginPath();
    ctx.moveTo(centerX + i, canvas.height - 50);
    ctx.lineTo(centerX + i - 10, canvas.height - 10);
    ctx.stroke();
  }
  
  // === TWO PARALLEL SPRINGS ===
  const floorTopY = canvas.height - 50;
  const barHeight = 28;
  const diskBottomY = diskY + barHeight/2;
  
  drawSpring(centerX - springSpacing, floorTopY, centerX - springSpacing, diskBottomY);
  drawSpring(centerX + springSpacing, floorTopY, centerX + springSpacing, diskBottomY);
  
  // === DISK/BAR ===
  const barWidth = 120;
  
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(centerX - barWidth/2 + 4, diskY - barHeight/2 + 4, barWidth, barHeight);
  
  const barGrad = ctx.createLinearGradient(0, diskY - barHeight/2, 0, diskY + barHeight/2);
  barGrad.addColorStop(0, '#999');
  barGrad.addColorStop(0.3, '#777');
  barGrad.addColorStop(1, '#555');
  ctx.fillStyle = barGrad;
  ctx.fillRect(centerX - barWidth/2, diskY - barHeight/2, barWidth, barHeight);
  
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 2;
  ctx.strokeRect(centerX - barWidth/2, diskY - barHeight/2, barWidth, barHeight);
  
  // Grid pattern
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 1;
  for (let x = centerX - barWidth/2 + 20; x < centerX + barWidth/2; x += 20) {
    ctx.beginPath();
    ctx.moveTo(x, diskY - barHeight/2);
    ctx.lineTo(x, diskY + barHeight/2);
    ctx.stroke();
  }
  
  // Spring bolts
  ctx.fillStyle = '#888';
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  [-springSpacing, springSpacing].forEach(offset => {
    ctx.beginPath();
    ctx.arc(centerX + offset, diskY + barHeight/2 - 2, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  });
  
  // === CLOWN HEAD ===
  if (!state.clownDetached) {
    // Clown still attached to disk
    drawClownHead(centerX, diskY - barHeight/2 - 28);
    
    // Show velocity arrow after collision (system going DOWN)
    if (state.collisionOccurred && state.velocity < 0) {
      ctx.strokeStyle = '#FF6B6B';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(centerX - 75, diskY);
      ctx.lineTo(centerX - 75, diskY + 35);
      ctx.stroke();
      
      // Arrow head pointing DOWN
      ctx.fillStyle = '#FF6B6B';
      ctx.beginPath();
      ctx.moveTo(centerX - 75, diskY + 42);
      ctx.lineTo(centerX - 82, diskY + 30);
      ctx.lineTo(centerX - 68, diskY + 30);
      ctx.closePath();
      ctx.fill();
      
      // Velocity label
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'right';
      ctx.fillText(`â†“ ${Math.abs(state.velocity).toFixed(2)} m/s`, centerX - 80, diskY + 20);
    }
  }
  
  // === BALL (waiting at equilibrium, visible from start) ===
  if (state.ballVisible && !state.collisionOccurred) {
    // Draw ball at its stored position (at equilibrium, waiting for collision)
    drawBallAtPosition(centerX, state.ballStartY);
    
    ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
    ctx.font = 'bold 10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('â† Î²ÏŒÎ»Î¿Ï‚ (Î±ÎºÎ¯Î½Î·Ï„Î¿Ï‚)', centerX + 35, state.ballStartY + 4);
  }
}

function drawBallAtPosition(x, y) {
  ctx.save();
  ctx.translate(x, y);
  
  // Ball shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(4, 6, 18, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Ball (iron/metal sphere)
  const ballGrad = ctx.createRadialGradient(-6, -6, 2, 0, 0, 22);
  ballGrad.addColorStop(0, '#bbb');
  ballGrad.addColorStop(0.4, '#888');
  ballGrad.addColorStop(1, '#444');
  ctx.fillStyle = ballGrad;
  ctx.beginPath();
  ctx.arc(0, 0, 22, 0, Math.PI * 2);
  ctx.fill();
  
  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.beginPath();
  ctx.arc(-7, -7, 7, 0, Math.PI * 2);
  ctx.fill();
  
  // Label
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 11px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('mâ‚ƒ', 0, 2);
  
  ctx.restore();
}

function drawSpring(x1, y1, x2, y2) {
  const dy = y2 - y1;
  const length = Math.abs(dy);
  const coils = 14;
  const amplitude = 10;
  
  // Natural length based on equilibrium position
  const floorY = canvas.height - 50;
  const naturalLength = Math.abs(state.naturalLengthY + 14 - floorY); // Natural length of each spring
  
  // Color based on compression/extension
  const stretch = length / naturalLength;
  let color;
  if (stretch > 1.08) {
    color = '#FF6B6B'; // Extended - red (tension)
  } else if (stretch < 0.92) {
    color = '#4ECDC4'; // Compressed - cyan
  } else {
    color = '#7ED321'; // Natural - green
  }
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  
  // Start point
  ctx.moveTo(x1, y1);
  
  // Draw coils (zigzag pattern)
  const numSegments = coils + 1;
  const segmentHeight = dy / numSegments;
  
  for (let i = 1; i <= coils; i++) {
    const py = y1 + segmentHeight * i;
    const direction = (i % 2 === 0) ? 1 : -1;
    const px = x1 + direction * amplitude;
    ctx.lineTo(px, py);
  }
  
  // End point
  ctx.lineTo(x2, y2);
  ctx.stroke();
  
  // End caps (attachment points)
  ctx.fillStyle = '#666';
  ctx.beginPath();
  ctx.arc(x1, y1, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x2, y2, 5, 0, Math.PI * 2);
  ctx.fill();
}

function drawClownHead(x, y) {
  ctx.save();
  ctx.translate(x, y);
  
  // Face
  const faceGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
  faceGrad.addColorStop(0, '#FFE4C4');
  faceGrad.addColorStop(1, '#FFDAB9');
  ctx.fillStyle = faceGrad;
  ctx.beginPath();
  ctx.arc(0, 0, 25, 0, Math.PI * 2);
  ctx.fill();
  
  // Red nose
  ctx.fillStyle = '#FF0000';
  ctx.beginPath();
  ctx.arc(0, 5, 8, 0, Math.PI * 2);
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(-10, -5, 4, 0, Math.PI * 2);
  ctx.arc(10, -5, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // Smile
  ctx.strokeStyle = '#FF0000';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 5, 15, 0.2, Math.PI - 0.2);
  ctx.stroke();
  
  // Hair tufts
  ctx.fillStyle = '#FF6B00';
  ctx.beginPath();
  ctx.arc(-20, -20, 10, 0, Math.PI * 2);
  ctx.arc(20, -20, 10, 0, Math.PI * 2);
  ctx.arc(0, -28, 10, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
}

function drawDetachedClown() {
  if (!state.clownDetached) return;
  
  const wobble = Math.sin(state.t * 15) * 3;
  drawClownHead(state.clownPos.x + wobble, state.clownPos.y);
  
  // Show velocity indicator
  if (Math.abs(state.clownVel) > 0.1) {
    const arrowDir = state.clownVel > 0 ? -1 : 1;
    ctx.strokeStyle = state.clownVel > 0 ? '#7ED321' : '#FF6B6B';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(state.clownPos.x - 35, state.clownPos.y);
    ctx.lineTo(state.clownPos.x - 35, state.clownPos.y + arrowDir * 20);
    ctx.stroke();
    
    ctx.fillStyle = ctx.strokeStyle;
    ctx.font = '10px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText(`${state.clownVel.toFixed(1)} m/s`, state.clownPos.x - 40, state.clownPos.y);
  }
}

function drawBall() {
  // Ball after collision - show it going UP
  if (state.collisionOccurred && state.ballActive) {
    drawBallAtPosition(state.ballPos.x, state.ballPos.y);
    
    // Show velocity arrow pointing UP
    ctx.strokeStyle = '#4ECDC4';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(state.ballPos.x + 35, state.ballPos.y);
    ctx.lineTo(state.ballPos.x + 35, state.ballPos.y - 35);
    ctx.stroke();
    
    // Arrow head pointing UP
    ctx.fillStyle = '#4ECDC4';
    ctx.beginPath();
    ctx.moveTo(state.ballPos.x + 35, state.ballPos.y - 42);
    ctx.lineTo(state.ballPos.x + 28, state.ballPos.y - 30);
    ctx.lineTo(state.ballPos.x + 42, state.ballPos.y - 30);
    ctx.closePath();
    ctx.fill();
    
    // Velocity label
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(`â†‘ ${state.ballVel.toFixed(2)} m/s`, state.ballPos.x + 48, state.ballPos.y - 20);
  }
}

function drawTrail() {
  if (state.trail.length < 2) return;
  
  ctx.lineWidth = 3;
  for (let i = 1; i < state.trail.length; i++) {
    const age = state.t - state.trail[i].time;
    const alpha = Math.max(0, 1 - age / 2);
    ctx.strokeStyle = `rgba(255, 107, 157, ${alpha * 0.6})`;
    ctx.beginPath();
    ctx.moveTo(state.trail[i-1].x, state.trail[i-1].y);
    ctx.lineTo(state.trail[i].x, state.trail[i].y);
    ctx.stroke();
  }
}

function drawVelocityVector() {
  if (Math.abs(state.velocity) < 0.01) return;
  
  const centerX = canvas.width / 2;
  const scale = 20; // pixels per m/s
  const arrowLength = state.velocity * scale;
  
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(centerX + 70, state.diskVisualY);
  ctx.lineTo(centerX + 70, state.diskVisualY - arrowLength);
  ctx.stroke();
  
  // Arrow head
  const headSize = 8;
  const direction = state.velocity > 0 ? -1 : 1;
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(centerX + 70, state.diskVisualY - arrowLength);
  ctx.lineTo(centerX + 70 - headSize, state.diskVisualY - arrowLength + direction * headSize * 1.5);
  ctx.lineTo(centerX + 70 + headSize, state.diskVisualY - arrowLength + direction * headSize * 1.5);
  ctx.closePath();
  ctx.fill();
  
  // Label
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 12px system-ui';
  ctx.fillText(`v = ${state.velocity.toFixed(2)} m/s`, centerX + 85, state.diskVisualY - arrowLength / 2);
}

/* ========================================
   GAME LOOP
======================================== */
let lastTime = 0;

function gameLoop(timestamp) {
  if (state.phase === 'menu') return;
  if (state.paused) {
    draw();
    return;
  }
  
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;
  
  if (state.phase === 'oscillating') {
    updatePhysics(dt);
  }
  
  draw();
  
  if (state.phase !== 'end') {
    requestAnimationFrame(gameLoop);
  }
}

/* ========================================
   START
======================================== */
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
