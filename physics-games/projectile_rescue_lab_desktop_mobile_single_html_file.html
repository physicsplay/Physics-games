<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Projectile Rescue Lab</title>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    #layout{
      display: flex;
      gap: 12px;
      padding: 10px;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    #sidePanel{
      width: 380px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #gameWrap{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #gameCanvas{
      display: block;
      background: linear-gradient(to bottom, #4A90E2 0%, #7B9EC9 40%, #2C5F7F 60%, #1A3A4F 100%);
      box-shadow: 0 15px 50px rgba(0,0,0,0.5);
      border-radius: 10px;
      width: min(1200px, calc(100vw - 24px));
      height: auto;
      touch-action: none;
    }

    .hud{
      background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(60,60,60,0.95) 100%);
      color: white;
      padding: 14px;
      border-radius: 15px;
      font-size: 14px;
      line-height: 1.55;
      border: 2px solid rgba(102,126,234,0.5);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }

    .lab-panel{
      background: linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(240,240,255,0.98) 100%);
      border: 3px solid #667eea;
      border-radius: 15px;
      padding: 14px;
      width: 380px;
      display: none;
      box-shadow: 0 10px 40px rgba(102,126,234,0.3);
    }
    .lab-panel.visible{ display:block; }

    .energy-bar{
      height: 18px;
      background: #ddd;
      border-radius: 10px;
      margin: 6px 0;
      overflow: hidden;
    }
    .energy-fill{ height: 100%; transition: width 0.1s; }
    .ek{ background: linear-gradient(to right, #4CAF50, #81C784); }
    .ep{ background: linear-gradient(to right, #2196F3, #64B5F6); }
    .em{ background: linear-gradient(to right, #FF9800, #FFB74D); }

    .graph{
      width: 100%;
      height: 120px;
      border: 1px solid #ccc;
      margin: 10px 0 0 0;
      background: white;
      border-radius: 8px;
    }

    button{
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      box-shadow: 0 4px 15px rgba(102,126,234,0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      width: 100%;
    }
    button:hover{
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102,126,234,0.6);
    }
    button:active{ transform: translateY(0); }

    .btnRow{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .btnRow3{
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    .status-line{
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.92;
    }

    .section-divider{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.2);
    }

    .medal{ font-size: 24px; margin: 10px 0 0 0; }

    .hint-box{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.18);
      display: none;
      line-height: 1.45;
      font-size: 13px;
    }

    .controlBlock{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
    }

    .controlTitle{ font-weight: 800; margin-bottom: 8px; }

    .sliderRow{
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    .sliderLabel{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      opacity: 0.95;
    }

    input[type="range"]{
      width: 100%;
      accent-color: #FFD700;
    }

    .mini{ font-size: 12px; opacity: 0.9; }

    .intro-screen, .win-screen{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 1000;
      padding: 14px;
    }

    .screen-content{
      max-width: 860px;
      width: 100%;
      padding: 26px;
      text-align: center;
      background: linear-gradient(135deg, rgba(20,20,30,0.98) 0%, rgba(40,30,50,0.98) 100%);
      border-radius: 22px;
      border: 3px solid #667eea;
      box-shadow: 0 20px 60px rgba(0,0,0,0.7);
    }

    .screen-content h1{
      color: #FFD700;
      margin-bottom: 14px;
      font-size: 34px;
      text-shadow: 0 0 20px rgba(255,215,0,0.5);
    }
    .screen-content p{ line-height: 1.65; margin: 10px 0; font-size: 16px; }
    .hidden{ display:none !important; }

    /* Mobile: stack everything (canvas then panel). No overlays on the moving area. */
    @media (max-width: 980px){
      body{ overflow: auto; }
      #layout{ padding: 8px; }
      #sidePanel{ width: min(520px, 100%); }
      .lab-panel{ width: min(520px, 100%); }
      .screen-content h1{ font-size: 28px; }
      .screen-content p{ font-size: 15px; }
    }

    @media (max-width: 520px){
      .btnRow3{ grid-template-columns: 1fr 1fr; }
      button{ padding: 12px 14px; font-size: 15px; }
      #snapshotBlock{ display: none; }
      .section-divider.mini{ display: none; }
    }

    /* Fullscreen (best effort across browsers) */
    body.isFullscreen{
      overflow: auto;
    }
    body.isFullscreen #layout{
      padding: 0;
      gap: 10px;
    }
    body.isFullscreen #gameCanvas{
      width: 100vw;
      border-radius: 0;
    }
    body.isFullscreen #sidePanel{
      width: min(520px, 100vw);
    }
  </style>
</head>

<body>

  <div id="layout">

    <div id="gameWrap">
      <canvas id="gameCanvas" width="1200" height="700"></canvas>
      <div class="mini" style="color: rgba(255,255,255,0.9); text-align:center; max-width: 1200px;">
        Tip: On phones, use the sliders and the buttons below. (No keyboard needed.)
      </div>
    </div>

    <div id="sidePanel">

      <div class="hud">
        <div id="hudText">
          <strong>Projectile Rescue Lab</strong><br>
          Vertical drop (h): <span id="heightText">5.0</span> m<br>
          Horizontal distance (d): <span id="distText">20.0</span> m<br>
          Launch speed (vâ‚€): <span id="velocityText">15.0</span> m/s<br>
          Attempts: <span id="attemptText">0</span> |
          Score: <span id="scoreValue">--</span>/100 |
          Hints used: <span id="hintCount">0</span><br>

          <div class="section-divider mini">
            Keyboard (optional): â†‘/â†“ vâ‚€ | SPACE launch | R reset | L lab | S slow | P pause | N step | K hint
          </div>
        </div>

        <div class="controlBlock">
          <div class="controlTitle">Touch controls</div>

          <div class="sliderRow">
            <div class="sliderLabel"><span>Launch speed vâ‚€ (m/s)</span><strong id="v0Val">15.0</strong></div>
            <input id="v0Slider" type="range" min="5" max="40" step="0.5" value="15" />

            <div class="sliderLabel"><span>Vertical drop h (m)</span><strong id="hVal">5.0</strong></div>
            <input id="hSlider" type="range" min="1" max="15" step="0.5" value="5" />

            <div class="sliderLabel"><span>Horizontal distance d (m)</span><strong id="dVal">20</strong></div>
            <input id="dSlider" type="range" min="5" max="50" step="1" value="20" />
          </div>

          <div class="btnRow" style="margin-top:12px;">
            <button onclick="launch()">ðŸš€ Launch</button>
            <button onclick="resetAttempt()">ðŸ”„ Reset</button>
          </div>

          <div class="btnRow3">
            <button onclick="togglePause()">â¸ Pause</button>
            <button onclick="toggleSlowMo()">ðŸŒ Slow</button>
            <button onclick="stepForward()">â­ Step</button>
          </div>

          <div class="btnRow">
            <button onclick="toggleLab()">ðŸ”¬ Lab</button>
            <button onclick="showHint()">ðŸ’¡ Hint</button>
          </div>

          <div class="btnRow">
            <button onclick="toggleFullscreen()">â›¶ <span id="fsBtnText">Fullscreen</span></button>
            <button onclick="toggleSound()">ðŸ”Š Sound: <span id="soundStatus">ON</span></button>
          </div>

          <div class="status-line">
            Slow motion: <strong><span id="slowMoStatus">OFF</span></strong> |
            Pause: <strong><span id="pauseStatus">OFF</span></strong>
          </div>
        </div>

        <div class="hint-box" id="hintBox"></div>

        <div id="snapshotBlock" class="section-divider">
          <strong>Snapshot (instant values):</strong><br>
          Time (t): <span id="snapT">0.000</span> s<br>
          Horizontal position (x): <span id="snapX">0.00</span> m<br>
          Vertical position (y): <span id="snapY">0.00</span> m<br>
          Horizontal velocity (vâ‚“): <span id="snapVx">0.00</span> m/s<br>
          Vertical velocity (váµ§): <span id="snapVy">0.00</span> m/s<br>
          Speed (v): <span id="snapV">0.00</span> m/s
        </div>

        <div id="resultText" style="margin-top:10px; font-size:16px; font-weight:800;"></div>
        <div id="medalText" class="medal"></div>
      </div>

      <div class="lab-panel" id="labPanel">
        <h3 style="margin-bottom:10px; color:#2196F3;">ðŸ”¬ Physics Lab</h3>

        <div style="margin:10px 0;">
          <strong>Energy (J):</strong><br>
          Kinetic energy (Eâ‚–): <span id="ekText">0</span> J
          <div class="energy-bar"><div class="energy-fill ek" id="ekBar" style="width:0%"></div></div>

          Gravitational potential energy (Eâ‚š): <span id="epText">0</span> J
          <div class="energy-bar"><div class="energy-fill ep" id="epBar" style="width:0%"></div></div>

          Mechanical energy (Eâ‚˜): <span id="emText">0</span> J
          <div class="energy-bar"><div class="energy-fill em" id="emBar" style="width:0%"></div></div>
        </div>

        <div style="margin:15px 0 10px 0;">
          <strong>Prediction (no air resistance):</strong><br>
          Fall time (t): <span id="theoryTime">0</span> s<br>
          Required launch speed (vâ‚€): <span id="theoryV0">0</span> m/s
        </div>

        <div style="margin:10px 0 0 0;">
          <strong>Measured values (at target height):</strong><br>
          Time (t): <span id="measTime">0</span> s<br>
          Range (x): <span id="measDist">0</span> m<br>
          Percent error (%): <span id="errorPercent">0</span>%
        </div>

        <canvas id="graphCanvas" class="graph"></canvas>
      </div>

    </div>
  </div>

  <div class="intro-screen" id="introScreen">
    <div class="screen-content">
      <h1>âš¡ Projectile Rescue Lab âš¡</h1>
      <p style="color:#FF5252; font-weight:800;">ðŸŒŠ EMERGENCY SITUATION ðŸŒŠ</p>
      <p>Unprecedented rainfall in <strong>Our City</strong>! Extreme weather events are becoming more frequent and more intense...</p>
      <p><strong style="color:#FF9800;">The river has overflowed.</strong> All bridges have collapsed. The city has been split in two!</p>
      <p style="margin-top:10px;">Grandma Litsa is trapped across the way. She urgently needs her <strong style="color:#4CAF50;">insulin</strong>, but there is no way to reach a hospital.</p>
      <p style="margin-top:10px;">You are on the rooftop of <strong>Our School</strong>. The only hope is the horizontal launcher you built in the Physics lab!</p>
      <p style="color:#FFD700; font-size:18px; margin-top:14px;"><strong>ðŸ’¡ Use projectile motion to save Grandma Litsa!</strong></p>

      <div style="text-align:left; margin-top:14px; font-size:14px; color:#B0BEC5; line-height:1.55;">
        <strong>How scoring works (max 100):</strong><br>
        â€¢ <strong>Attempts (70% of the score):</strong> you start with 70 points. Each extra attempt subtracts 7 points.<br>
        &nbsp;&nbsp;Attempts points = max(0, 70 âˆ’ 7Â·(attempts âˆ’ 1)).<br>
        â€¢ <strong>Accuracy (30% of the score):</strong> determined by the medal of the successful shot:<br>
        &nbsp;&nbsp;ðŸ¥‡ Gold: error â‰¤ 1% â†’ penalty 0 â†’ 30 points<br>
        &nbsp;&nbsp;ðŸ¥ˆ Silver: error â‰¤ 3% â†’ penalty 8 â†’ 22 points<br>
        &nbsp;&nbsp;ðŸ¥‰ Bronze: error > 3% â†’ penalty 16 â†’ 14 points<br>
        â€¢ <strong>Hints:</strong> each hint subtracts 5 points.<br><br>
        <strong>Final score</strong> = Attempts points + Accuracy points âˆ’ 5Â·(hints used), clamped to 0â€¦100.
      </div>

      <button onclick="startGame()" style="font-size:18px; padding:14px 26px; margin-top:16px; width:auto;">ðŸš€ Start Mission</button>
      <p class="mini" style="margin-top:10px;">Phone users: use the sliders and buttons. Keyboard is optional.</p>
    </div>
  </div>

  <div class="win-screen hidden" id="winScreen">
    <div class="screen-content">
      <h1>ðŸŽ‰ SUCCESS! ðŸŽ‰</h1>
      <p id="winMessage"></p>
      <div id="winMedal" class="medal"></div>
      <p id="winScore"></p>
      <p id="winScience"></p>
      <button onclick="location.reload()" style="font-size:18px; padding:14px 26px; margin-top:14px; width:auto;">ðŸ”„ Try Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');

    const PPM = 50;           // pixels per meter (visual scale)
    const g = 9.81;           // m/s^2

    // Medal thresholds (as requested)
    const GOLD_MAX = 1.0;     // â‰¤ 1%
    const SILVER_MAX = 3.0;   // â‰¤ 3%

    let h = 5.0;              // vertical drop (m)
    let d = 20.0;             // horizontal distance (m)
    const m = 0.5;            // mass (kg)

    // Scene geometry
    const groundLevel = 520;
    const launcherX = 150;
    const TARGET_HANDS_Y = groundLevel - 190;

    let cameraY = 0;
    const CAMERA_MIN_ROOF = 70;
    const CAMERA_MAX_SHIFT = 200;
    const MAX_H = 15.0;

    // Time control
    let slowMo = false;
    let timeScale = 1.0;
    let isPaused = false;
    const STEP_DT = 0.02;
    let stepOnce = false;

    // Sound
    let soundEnabled = true;
    let audioCtx = null;

    // Hint system
    let hintsUsed = 0;
    let hintCooldown = false;
    let hintHideTimer = null;

    // Static background buildings (no flicker)
    const backgroundBuildings = [
      {x: 50,  h: 140, seed: 11},
      {x: 300, h: 100, seed: 22},
      {x: 550, h: 120, seed: 33},
      {x: 800, h:  90, seed: 44},
      {x: 1000,h: 110, seed: 55}
    ];

    // Speech bubble
    let bubble = { active:false, text:'', x:0, y:0, timer:0 };

    // Objects positions
    let school = { top: 0, height: 0, roofY: 0, launchY: 0 };
    let targetX = 0;
    let targetY = TARGET_HANDS_Y;

    // Theoretical prediction
    let t_theory = 0;
    let v0_theory = 0;

    // Game state
    let gameState = {
      v0: 15.0,
      moving: false,
      measured: false,
      success: false,
      outcome: "none",

      attempts: 0,
      score: null,

      x: 0, y: 0,
      vx: 0, vy: 0,
      t: 0,

      measT: 0,
      measX: 0,

      hitWater: false,
      splash: {active:false, x:0, y:0, timer:0},

      // Trail stays visible for 3 seconds after the shot
      trail: [],
      trailVisible: false,
      trailRecording: false,
      trailHold: 0,

      energyHistory: []
    };

    function getAudioCtx(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }

    function playSillySound(){
      if (!soundEnabled) return;
      const ac = getAudioCtx();
      const t0 = ac.currentTime;
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(650, t0);
      osc.frequency.exponentialRampToValueAtTime(1300, t0 + 0.08);
      osc.frequency.exponentialRampToValueAtTime(220, t0 + 0.28);
      gain.gain.setValueAtTime(0.0001, t0);
      gain.gain.exponentialRampToValueAtTime(0.35, t0 + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.35);
      osc.connect(gain).connect(ac.destination);
      osc.start(t0);
      osc.stop(t0 + 0.36);
    }

    // Haptics (mobile vibration) â€” safe no-op if unsupported
    function vibrate(pattern){
      if (!('vibrate' in navigator)) return;
      try{ navigator.vibrate(pattern); } catch(e) {}
    }

    // Fullscreen (best effort â€” may be limited on iOS Safari)
    async function toggleFullscreen(){
      const el = document.documentElement;
      const resultText = document.getElementById('resultText');
      try{
        if (!document.fullscreenElement && el.requestFullscreen){
          await el.requestFullscreen();
        } else if (document.fullscreenElement && document.exitFullscreen){
          await document.exitFullscreen();
        } else {
          if (resultText) resultText.innerHTML = '<span style="color:#FFD700;">Fullscreen is not supported on this browser.</span>';
        }
      } catch(err){
        if (resultText) resultText.innerHTML = '<span style="color:#FFD700;">Fullscreen could not be activated.</span>';
      }
      updateFullscreenUI();
    }

    function updateFullscreenUI(){
      const on = !!document.fullscreenElement;
      document.body.classList.toggle('isFullscreen', on);
      const t = document.getElementById('fsBtnText');
      if (t) t.textContent = on ? 'Exit' : 'Fullscreen';
    }

    document.addEventListener('fullscreenchange', updateFullscreenUI);

    function clampInputs(){
      h = Math.max(1.0, Math.min(MAX_H, h));
      d = Math.max(5.0, Math.min(50.0, d));
      gameState.v0 = Math.max(5.0, Math.min(40.0, gameState.v0));
    }

    function updateStatusUI(){
      document.getElementById('slowMoStatus').textContent = slowMo ? 'ON' : 'OFF';
      document.getElementById('pauseStatus').textContent = isPaused ? 'ON' : 'OFF';
      document.getElementById('soundStatus').textContent = soundEnabled ? 'ON' : 'OFF';
      document.getElementById('hintCount').textContent = hintsUsed;
    }

    function updateAttemptScoreUI(){
      document.getElementById('attemptText').textContent = gameState.attempts;
      document.getElementById('scoreValue').textContent = (gameState.score === null) ? '--' : gameState.score;
      document.getElementById('hintCount').textContent = hintsUsed;
    }

    function toggleSlowMo(){
      slowMo = !slowMo;
      timeScale = slowMo ? 0.25 : 1.0;
      updateStatusUI();
    }

    function togglePause(){
      isPaused = !isPaused;
      updateStatusUI();
    }

    function stepForward(){
      if (!gameState.moving) return;
      if (!isPaused) { isPaused = true; updateStatusUI(); }
      stepOnce = true;
    }

    function toggleSound(){
      soundEnabled = !soundEnabled;
      updateStatusUI();
    }

    function toggleLab(){
      document.getElementById('labPanel').classList.toggle('visible');
    }

    // Scoring
    function medalTierFromError(errorPercent){
      if (errorPercent <= GOLD_MAX) return 'gold';
      if (errorPercent <= SILVER_MAX) return 'silver';
      return 'bronze';
    }

    function accuracyPenaltyFromTier(tier){
      if (tier === 'gold') return 0;
      if (tier === 'silver') return 8;
      return 16;
    }

    function medalFromAccuracy(errorPercent){
      const tier = medalTierFromError(errorPercent);
      if (tier === 'gold') return 'ðŸ¥‡ Gold!';
      if (tier === 'silver') return 'ðŸ¥ˆ Silver!';
      return 'ðŸ¥‰ Bronze!';
    }

    // 70% attempts + 30% accuracy (medal penalty), plus -5 per hint
    function computeScore(attempts, errorPercent, hints){
      const extraAttempts = Math.max(0, attempts - 1);
      const attemptsPoints = Math.max(0, 70 - 7 * extraAttempts);
      const tier = medalTierFromError(errorPercent);
      const penalty = accuracyPenaltyFromTier(tier);
      const accuracyPoints = Math.max(0, 30 - penalty);
      const raw = attemptsPoints + accuracyPoints - 5 * hints;
      return Math.max(0, Math.min(100, Math.round(raw)));
    }

    function updateTheory(){
      clampInputs();
      t_theory = Math.sqrt(2 * h / g);
      v0_theory = d / t_theory;
      document.getElementById('heightText').textContent = h.toFixed(1);
      document.getElementById('distText').textContent = d.toFixed(1);
      document.getElementById('theoryTime').textContent = t_theory.toFixed(3);
      document.getElementById('theoryV0').textContent = v0_theory.toFixed(2);

      // Sliders (mobile/desktop touch)
      document.getElementById('hVal').textContent = h.toFixed(1);
      document.getElementById('dVal').textContent = d.toFixed(0);
      document.getElementById('v0Val').textContent = gameState.v0.toFixed(1);
    }

    function updatePositions(){
      targetX = launcherX + d * PPM;
      targetY = TARGET_HANDS_Y;

      // Launch point is h meters above the target hands
      school.launchY = targetY - h * PPM;
      school.roofY = school.launchY - 6;
      school.top = school.roofY + 10;
      school.height = (groundLevel - school.top);

      // Camera keeps roof visible
      cameraY = Math.min(CAMERA_MAX_SHIFT, Math.max(0, CAMERA_MIN_ROOF - school.roofY));
    }

    function showHint(){
      if (hintCooldown) return;
      hintCooldown = true;
      setTimeout(() => hintCooldown = false, 250);

      hintsUsed++;
      updateStatusUI();
      updateAttemptScoreUI();

      updateTheory();

      const hintBox = document.getElementById('hintBox');
      hintBox.style.display = 'block';
      hintBox.innerHTML = `
        <strong>Hint (cost: -5 points)</strong><br>
        1) Fall time: <strong>t = âˆš(2h/g)</strong><br>
        &nbsp;&nbsp;= âˆš(2Ã—${h.toFixed(1)}/${g.toFixed(2)}) = <strong>${t_theory.toFixed(3)} s</strong><br><br>
        2) Horizontal motion: <strong>x = vâ‚€Â·t</strong> â†’ <strong>vâ‚€ = d/t</strong><br>
        &nbsp;&nbsp;= ${d.toFixed(1)}/${t_theory.toFixed(3)} = <strong>${v0_theory.toFixed(2)} m/s</strong>
      `;

      if (hintHideTimer) clearTimeout(hintHideTimer);
      hintHideTimer = setTimeout(() => { hintBox.style.display = 'none'; }, 2200);
    }

    function updateSnapshotUI(){
      const t = gameState.t;
      const x = gameState.x;
      const y = gameState.y;
      const vx = gameState.vx;
      const vy = gameState.vy;
      const v = Math.sqrt(vx*vx + vy*vy);
      document.getElementById('snapT').textContent = t.toFixed(3);
      document.getElementById('snapX').textContent = x.toFixed(2);
      document.getElementById('snapY').textContent = y.toFixed(2);
      document.getElementById('snapVx').textContent = vx.toFixed(2);
      document.getElementById('snapVy').textContent = vy.toFixed(2);
      document.getElementById('snapV').textContent = v.toFixed(2);
      document.getElementById('velocityText').textContent = gameState.v0.toFixed(1);
    }

    function drawWindowGrid(xLeft, yTop, w, hH, rows, cols, color, blur, alpha, seed){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = blur;

      const padX = 12;
      const padY = 18;
      const usableW = w - 2*padX;
      const usableH = hH - 2*padY;

      const winW = Math.max(10, usableW / cols * 0.35);
      const winH = Math.max(10, usableH / rows * 0.25);

      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          const key = (seed + r*37 + c*19) % 5;
          if (key === 0) continue;

          const xx = xLeft + padX + (c + 0.5) * (usableW / cols) - winW/2;
          const yy = yTop  + padY + (r + 0.5) * (usableH / rows) - winH/2;
          ctx.fillRect(xx, yy, winW, winH);
        }
      }
      ctx.restore();
    }

    function drawSpeechBubble(text, x, y, alpha=1.0){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = '700 14px Arial';
      ctx.textAlign = 'center';
      const padding = 10;
      const textW = ctx.measureText(text).width;
      const w = textW + padding*2;
      const hBox = 30;

      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 2;

      const r = 10;
      const left = x - w/2;
      const top = y - hBox;

      ctx.beginPath();
      ctx.moveTo(left + r, top);
      ctx.lineTo(left + w - r, top);
      ctx.quadraticCurveTo(left + w, top, left + w, top + r);
      ctx.lineTo(left + w, top + hBox - r);
      ctx.quadraticCurveTo(left + w, top + hBox, left + w - r, top + hBox);
      ctx.lineTo(left + r, top + hBox);
      ctx.quadraticCurveTo(left, top + hBox, left, top + hBox - r);
      ctx.lineTo(left, top + r);
      ctx.quadraticCurveTo(left, top, left + r, top);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x - 8, top + hBox);
      ctx.lineTo(x, top + hBox + 10);
      ctx.lineTo(x + 8, top + hBox);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#111';
      ctx.fillText(text, x, top + 20);
      ctx.restore();
    }

    function drawTrajectoryTrail(){
      if (!gameState.trailVisible || gameState.trail.length < 2) return;

      const alpha = gameState.trailRecording ? 1.0 : Math.max(0, 1 - (gameState.trailHold / 3));
      if (alpha <= 0) return;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = 'rgba(255, 87, 34, 0.55)';
      ctx.lineWidth = 4;
      ctx.beginPath();

      const p0 = gameState.trail[0];
      ctx.moveTo(launcherX + p0.x * PPM, (school.launchY + p0.y * PPM) + cameraY);
      for (const p of gameState.trail){
        ctx.lineTo(launcherX + p.x * PPM, (school.launchY + p.y * PPM) + cameraY);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawBackground(){
      const skyGrad = ctx.createLinearGradient(0, 0, 0, 320);
      skyGrad.addColorStop(0, '#4A5568');
      skyGrad.addColorStop(0.5, '#2D3748');
      skyGrad.addColorStop(1, '#1A202C');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, 320);

      // Rain
      ctx.strokeStyle = 'rgba(200, 220, 255, 0.3)';
      ctx.lineWidth = 1;
      for (let i=0; i<110; i++){
        const x = Math.random() * canvas.width;
        const y = (Date.now() * 0.5 + i * 50) % canvas.height;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - 5, y + 15);
        ctx.stroke();
      }

      // Background buildings
      ctx.fillStyle = '#4A5568';
      for (let b of backgroundBuildings){
        const top = (320 - b.h) + cameraY;
        ctx.fillRect(b.x, top, 180, b.h);
        drawWindowGrid(b.x, top, 180, b.h, 3, 3, 'rgba(255,167,38,0.55)', 5, 1.0, b.seed);
      }

      // Water
      const waterY = groundLevel + cameraY;
      const riverGrad = ctx.createLinearGradient(0, waterY, 0, canvas.height);
      riverGrad.addColorStop(0, '#1E3A5F');
      riverGrad.addColorStop(1, '#0F1C2E');
      ctx.fillStyle = riverGrad;
      ctx.fillRect(0, waterY, canvas.width, canvas.height - waterY);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.lineWidth = 3;
      for (let i=0; i<8; i++){
        ctx.beginPath();
        for (let x=0; x<canvas.width; x+=15){
          const yy = (waterY + 10) + i*30 + Math.sin(x*0.08 + Date.now()*0.003 + i)*8;
          ctx.lineTo(x, yy);
        }
        ctx.stroke();
      }

      // Splash
      if (gameState.splash.active){
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, gameState.splash.timer / 0.6));
        ctx.strokeStyle = 'rgba(200,240,255,0.9)';
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(gameState.splash.x, gameState.splash.y, 18, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(gameState.splash.x, gameState.splash.y, 32, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }

    function drawStudentsOnRoof(){
      const roofY = school.roofY + cameraY;
      const students = [
        {dx: -30, shirt: '#E91E63', skin: '#FFE082'},
        {dx: 0,   shirt: '#2196F3', skin: '#FFCC80'},
        {dx: 30,  shirt: '#4CAF50', skin: '#FFB74D'},
      ];
      for (const s of students){
        const x = launcherX + s.dx;
        const headY = roofY - 18;

        ctx.fillStyle = s.skin;
        ctx.beginPath(); ctx.arc(x, headY, 8, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = s.shirt;
        ctx.fillRect(x - 6, headY + 8, 12, 16);

        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - 3, headY + 24); ctx.lineTo(x - 6, headY + 34);
        ctx.moveTo(x + 3, headY + 24); ctx.lineTo(x + 6, headY + 34);
        ctx.stroke();

        // Arms (working on launcher)
        ctx.strokeStyle = s.skin;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, headY + 14);
        ctx.lineTo(x + 10, headY + 22);
        ctx.stroke();
      }
    }

    function drawLauncher(){
      const top = school.top + cameraY;
      const height = school.height;
      const bottom = groundLevel + cameraY;

      const buildingGrad = ctx.createLinearGradient(launcherX - 60, top, launcherX + 60, bottom);
      buildingGrad.addColorStop(0, '#1E3A5F');
      buildingGrad.addColorStop(1, '#2C5F7F');
      ctx.fillStyle = buildingGrad;
      ctx.fillRect(launcherX - 60, top, 120, height);

      ctx.strokeStyle = '#4A90E2';
      ctx.lineWidth = 2;
      ctx.strokeRect(launcherX - 60, top, 120, height);

      // Bright yellow school lights
      drawWindowGrid(launcherX - 60, top, 120, height, 5, 2, 'rgba(255, 213, 79, 0.95)', 10, 1.0, 777);

      const roofY = school.roofY + cameraY;
      ctx.fillStyle = '#0F1C2E';
      ctx.fillRect(launcherX - 70, roofY, 140, 15);

      // Sign
      ctx.fillStyle = 'rgba(102, 126, 234, 0.9)';
      ctx.fillRect(launcherX - 55, top + 18, 110, 32);
      ctx.strokeStyle = '#667eea';
      ctx.lineWidth = 2;
      ctx.strokeRect(launcherX - 55, top + 18, 110, 32);
      ctx.fillStyle = 'white';
      ctx.font = '700 12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Our', launcherX, top + 33);
      ctx.fillText('School', launcherX, top + 46);

      drawStudentsOnRoof();

      // Launcher
      const launchY = school.launchY + cameraY;
      const armGrad = ctx.createLinearGradient(launcherX, launchY, launcherX + 80, launchY);
      armGrad.addColorStop(0, '#667eea');
      armGrad.addColorStop(1, '#764ba2');
      ctx.strokeStyle = armGrad;
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(launcherX, launchY);
      ctx.lineTo(launcherX + 80, launchY);
      ctx.stroke();

      // Spring / energy
      const tension = gameState.v0 / 35;
      const springGrad = ctx.createLinearGradient(launcherX, launchY, launcherX + 80, launchY);
      springGrad.addColorStop(0, `rgba(102, 255, 102, ${tension})`);
      springGrad.addColorStop(0.5, `rgba(255, 255, 102, ${tension})`);
      springGrad.addColorStop(1, `rgba(255, 102, 102, ${tension})`);
      ctx.strokeStyle = springGrad;
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(launcherX, launchY + 12);
      for (let i=0; i<8; i++){
        const offset = (i % 2 === 0 ? 12 : -12) * tension;
        ctx.lineTo(launcherX + 10*(i+1), launchY + 12 + offset);
      }
      ctx.stroke();

      ctx.fillStyle = `rgba(255, 215, 0, ${tension})`;
      ctx.font = '700 14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`âš¡ ${Math.round(tension*100)}%`, launcherX + 10, launchY + 35);
    }

    function drawFunnyGrandma(x, y){
      // Balcony floor
      ctx.fillStyle = '#8D6E63';
      ctx.fillRect(x - 60, y - 10, 120, 8);
      ctx.fillStyle = '#6D4C41';
      ctx.fillRect(x - 60, y - 2, 120, 8);

      // Dress (triangle-ish)
      ctx.fillStyle = '#9C27B0';
      ctx.beginPath();
      ctx.moveTo(x - 16, y - 8);
      ctx.lineTo(x + 16, y - 8);
      ctx.lineTo(x + 24, y + 28);
      ctx.lineTo(x - 24, y + 28);
      ctx.closePath();
      ctx.fill();

      // Polka dots
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      for (let i=0; i<6; i++){
        ctx.beginPath();
        ctx.arc(x - 12 + (i%3)*12, y + 4 + Math.floor(i/3)*14, 2.5, 0, Math.PI*2);
        ctx.fill();
      }

      // Head
      ctx.fillStyle = '#FFECB3';
      ctx.beginPath();
      ctx.arc(x, y - 34, 14, 0, Math.PI*2);
      ctx.fill();

      // Hair bun + fringe
      ctx.fillStyle = '#BDBDBD';
      ctx.beginPath();
      ctx.arc(x + 8, y - 52, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y - 44, 15, Math.PI, 0, true);
      ctx.fill();

      // Glasses
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(x - 6, y - 36, 6, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(x + 6, y - 36, 6, 0, Math.PI*2); ctx.stroke();

      // Smile
      ctx.strokeStyle = '#C2185B';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y - 30, 7, 0, Math.PI);
      ctx.stroke();

      // Arms
      ctx.strokeStyle = '#FFECB3';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(x - 10, y - 10); ctx.lineTo(x - 22, y);
      ctx.moveTo(x + 10, y - 10); ctx.lineTo(x + 22, y);
      ctx.stroke();

      ctx.fillStyle = '#FFECB3';
      ctx.beginPath(); ctx.arc(x - 22, y, 5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 22, y, 5, 0, Math.PI*2); ctx.fill();
    }

    function drawTarget(){
      const buildingBottom = groundLevel + cameraY;
      const buildingHeight = 240;
      const buildingTop = buildingBottom - buildingHeight;

      ctx.fillStyle = '#5D4037';
      ctx.fillRect(targetX - 55, buildingTop, 110, buildingHeight);

      // Dim orange lights
      drawWindowGrid(targetX - 55, buildingTop, 110, buildingHeight, 4, 2, 'rgba(255,167,38,0.45)', 5, 1.0, 888);

      const handsY = targetY + cameraY;
      drawFunnyGrandma(targetX, handsY);

      // Label
      ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.fillRect(targetX - 64, handsY + 12, 128, 20);
      ctx.fillStyle = '#C2185B';
      ctx.font = '700 13px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Grandma Litsa', targetX, handsY + 26);

      if (bubble.active){
        const a = Math.max(0, Math.min(1, bubble.timer / 1.5));
        drawSpeechBubble(bubble.text, bubble.x, bubble.y, a);
      }
    }

    function drawPackage(){
      // At rest
      if (!gameState.moving && !gameState.measured){
        const lx = launcherX + 80;
        const ly = school.launchY + cameraY;
        ctx.fillStyle = '#FF5722';
        ctx.fillRect(lx - 8, ly - 8, 16, 16);
        ctx.fillStyle = 'white';
        ctx.fillRect(lx - 6, ly - 2, 12, 4);
        ctx.fillRect(lx - 2, ly - 6, 4, 12);
        return;
      }

      const px = launcherX + gameState.x * PPM;
      const py = (school.launchY + gameState.y * PPM) + cameraY;
      ctx.save();
      ctx.translate(px, py);
      const ang = Math.atan2(gameState.vy, gameState.vx || 0.0001);
      ctx.rotate(ang);
      ctx.fillStyle = '#FF5722';
      ctx.fillRect(-10, -10, 20, 20);
      ctx.fillStyle = 'white';
      ctx.fillRect(-8, -2, 16, 4);
      ctx.fillRect(-2, -8, 4, 16);
      ctx.restore();
    }

    // Coordinate convention: y is positive downward.
    // Target height is y = h (because launch point is at y=0 and target is h meters down).
    function waterDropMeters(){
      return (groundLevel - school.launchY) / PPM;
    }
    function bottomDropMeters(){
      return (canvas.height - 12 - school.launchY) / PPM;
    }

    function updatePhysics(dt){
      if (!gameState.moving || dt <= 0) return;

      gameState.t += dt;

      // Air: perfect parabola (vx constant, vy accelerated)
      if (!gameState.hitWater){
        gameState.vy += g * dt;
      } else {
        // Water: slower + drag
        const gWater = 3.2;
        gameState.vy += gWater * dt;
        gameState.vx *= Math.pow(0.82, dt * 60);
        gameState.vy *= Math.pow(0.94, dt * 60);
      }

      gameState.x += gameState.vx * dt;
      gameState.y += gameState.vy * dt;

      // Trail: record only in air
      if (gameState.trailRecording && !gameState.hitWater){
        gameState.trail.push({x: gameState.x, y: gameState.y});
      }

      // Energies
      const speed = Math.sqrt(gameState.vx*gameState.vx + gameState.vy*gameState.vy);
      const Ek = 0.5 * m * speed * speed;
      const Ep = m * g * Math.max(0, h - gameState.y);
      const Em = Ek + Ep;
      gameState.energyHistory.push({t: gameState.t, Ek, Ep, Em});

      // Measure at target height (y >= h)
      if (!gameState.measured && gameState.y >= h){
        gameState.measured = true;
        gameState.measT = gameState.t;
        gameState.measX = gameState.x;

        const tolerance = 0.5;
        const error = gameState.measX - d;
        const errorPercent = Math.abs(error) / d * 100;

        if (Math.abs(error) <= tolerance){
          // SUCCESS: snap to hands
          gameState.outcome = "success";
          gameState.success = true;

          gameState.x = d;
          gameState.y = h;
          gameState.vx = 0;
          gameState.vy = 0;
          gameState.moving = false;

          gameState.trailRecording = false;
          gameState.trailHold = 0;

          bubble.active = true;
          bubble.text = 'My medicine!';
          bubble.x = targetX;
          bubble.y = (targetY + cameraY) - 75;
          bubble.timer = 2.0;

          playSillySound();
          vibrate([30, 40, 30, 40, 60]);

          gameState.score = computeScore(gameState.attempts, errorPercent, hintsUsed);
          updateAttemptScoreUI();
          updateResultDisplay();

          setTimeout(showWinScreen, 900);
          return;

        } } else if (error > 0){
          // Too far: hit wall at target height
          gameState.outcome = "far";
          gameState.success = false;

          gameState.x = d;
          gameState.y = h;
          gameState.vx = 0;
          gameState.vy = 0;
          gameState.moving = false;

          gameState.trailRecording = false;
          gameState.trailHold = 0;

          // Wall hit haptics
          vibrate([70, 40, 70]);

          updateResultDisplay();
          return;

        } else {
          // Too short: keep moving (eventually water)
          gameState.outcome = "short";
          gameState.success = false;

          bubble.active = true;
          bubble.text = 'Oh noâ€¦ what a pity!';
          bubble.x = targetX;
          bubble.y = (targetY + cameraY) - 75;
          bubble.timer = 2.0;

          updateResultDisplay();
        }
      }

      // Enter water
      if (!gameState.hitWater && gameState.y >= waterDropMeters()){
        gameState.hitWater = true;

        if (gameState.trailRecording){
          gameState.trailRecording = false;
          gameState.trailHold = 0;
        }

        gameState.splash.active = true;
        gameState.splash.timer = 0.6;
        gameState.splash.x = launcherX + gameState.x * PPM;
        gameState.splash.y = (groundLevel + cameraY) + 6;

        // Splash haptics
        vibrate([120, 50, 80]);
      }

      // Sink to bottom
      if (gameState.hitWater && gameState.y >= bottomDropMeters()){
        gameState.moving = false;
      }
    }

    function updateResultDisplay(){
      const resultText = document.getElementById('resultText');
      const medalText = document.getElementById('medalText');
      if (!gameState.measured) return;

      const error = Math.abs(gameState.measX - d);
      const errorPercent = (error / d * 100);
      const epStr = errorPercent.toFixed(1);

      document.getElementById('measTime').textContent = gameState.measT.toFixed(3);
      document.getElementById('measDist').textContent = gameState.measX.toFixed(2);
      document.getElementById('errorPercent').textContent = epStr;

      if (gameState.outcome === "success"){
        resultText.innerHTML =
          `<span style="color:#4CAF50;">âœ“ SUCCESS! The medicine reached Grandma's hands.</span><br>
           Measured range (x): ${gameState.measX.toFixed(2)} m | Percent error (%): ${epStr}%<br>
           Attempts: ${gameState.attempts} | Hints: ${hintsUsed} | Final score: ${gameState.score}/100`;
        medalText.textContent = medalFromAccuracy(errorPercent);

      } else if (gameState.outcome === "far"){
        resultText.innerHTML =
          `<span style="color:#F44336;">âœ— Too far! It hit the wall.</span><br>
           Measured range (x): ${gameState.measX.toFixed(2)} m (needed ${d.toFixed(1)} m)`;
        medalText.textContent = '';

      } else if (gameState.outcome === "short"){
        resultText.innerHTML =
          `<span style="color:#F44336;">âœ— Too short! It missed the balcony.</span><br>
           Measured range (x): ${gameState.measX.toFixed(2)} m (needed ${d.toFixed(1)} m)`;
        medalText.textContent = '';
      }
    }

    function updateLabDisplay(){
      if (gameState.energyHistory.length === 0) return;
      const latest = gameState.energyHistory[gameState.energyHistory.length - 1];
      const Em0 = gameState.energyHistory[0].Em || 1;

      document.getElementById('ekText').textContent = latest.Ek.toFixed(2);
      document.getElementById('epText').textContent = latest.Ep.toFixed(2);
      document.getElementById('emText').textContent = latest.Em.toFixed(2);

      document.getElementById('ekBar').style.width = (latest.Ek / Em0 * 100) + '%';
      document.getElementById('epBar').style.width = (latest.Ep / Em0 * 100) + '%';
      document.getElementById('emBar').style.width = (latest.Em / Em0 * 100) + '%';

      drawGraph();
    }

    function drawGraph(){
      // Clear
      graphCanvas.width = graphCanvas.width;
      if (gameState.trail.length < 2) return;

      const padding = 26;
      const width = graphCanvas.width - 2*padding;
      const height = graphCanvas.height - 2*padding;

      // Axes
      graphCtx.strokeStyle = '#333';
      graphCtx.lineWidth = 1;
      graphCtx.beginPath();
      graphCtx.moveTo(padding, padding);
      graphCtx.lineTo(padding, graphCanvas.height - padding);
      graphCtx.lineTo(graphCanvas.width - padding, graphCanvas.height - padding);
      graphCtx.stroke();

      graphCtx.fillStyle = '#333';
      graphCtx.font = '11px Arial';
      graphCtx.fillText('x(t)', graphCanvas.width - padding - 22, graphCanvas.height - padding + 15);
      graphCtx.fillText('0', padding - 15, graphCanvas.height - padding + 5);

      const maxX = Math.max(...gameState.trail.map(p => p.x), d);

      // Trajectory on graph
      graphCtx.strokeStyle = '#2196F3';
      graphCtx.lineWidth = 2;
      graphCtx.beginPath();
      for (let i=0; i<gameState.trail.length; i++){
        const px = padding + (gameState.trail[i].x / maxX) * width;
        const py = graphCanvas.height - padding - (gameState.trail[i].y / (h + 1)) * height;
        if (i === 0) graphCtx.moveTo(px, py);
        else graphCtx.lineTo(px, py);
      }
      graphCtx.stroke();

      // Target line
      graphCtx.strokeStyle = '#4CAF50';
      graphCtx.setLineDash([3,3]);
      const targetPx = padding + (d / maxX) * width;
      graphCtx.beginPath();
      graphCtx.moveTo(targetPx, padding);
      graphCtx.lineTo(targetPx, graphCanvas.height - padding);
      graphCtx.stroke();
      graphCtx.setLineDash([]);
    }

    function render(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawLauncher();
      drawTarget();
      drawTrajectoryTrail();
      drawPackage();
    }

    let lastTime = 0;
    function gameLoop(timestamp){
      const dtRaw = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      let dtScaled = 0;
      if (isPaused){
        if (stepOnce){ dtScaled = STEP_DT; stepOnce = false; }
        else dtScaled = 0;
      } else {
        dtScaled = dtRaw * timeScale;
      }

      // Bubble timer
      if (bubble.active){
        bubble.timer -= dtRaw;
        if (bubble.timer <= 0) bubble.active = false;
      }

      // Splash timer
      if (gameState.splash.active){
        gameState.splash.timer -= dtRaw;
        if (gameState.splash.timer <= 0) gameState.splash.active = false;
      }

      // Trail hold
      if (gameState.trailVisible && !gameState.trailRecording){
        gameState.trailHold += dtRaw;
        if (gameState.trailHold >= 3){
          gameState.trailVisible = false;
          gameState.trail = [];
        }
      }

      updatePhysics(dtScaled);
      render();

      if (gameState.moving || document.getElementById('labPanel').classList.contains('visible')){
        updateLabDisplay();
      }

      updateSnapshotUI();
      requestAnimationFrame(gameLoop);
    }

    function startGame(){
      document.getElementById('introScreen').classList.add('hidden');

      updateTheory();
      updatePositions();

      updateStatusUI();
      updateAttemptScoreUI();
      updateFullscreenUI();
    }

    function showWinScreen(){
      const screen = document.getElementById('winScreen');
      const message = document.getElementById('winMessage');
      const medal = document.getElementById('winMedal');
      const science = document.getElementById('winScience');
      const scoreLine = document.getElementById('winScore');

      const error = Math.abs(gameState.measX - d);
      const errorPercent = (error / d * 100);
      const epStr = errorPercent.toFixed(1);

      message.textContent = 'The medicine landed safely. Grandma Litsa is saved!';
      medal.textContent = medalFromAccuracy(errorPercent);

      // Score breakdown
      const extraAttempts = Math.max(0, gameState.attempts - 1);
      const attemptsPoints = Math.max(0, 70 - 7 * extraAttempts);
      const tier = medalTierFromError(errorPercent);
      const penalty = accuracyPenaltyFromTier(tier);
      const accuracyPoints = Math.max(0, 30 - penalty);

      scoreLine.innerHTML =
        `<strong>Final score:</strong> ${gameState.score}/100<br>
         Attempts points: <strong>${attemptsPoints}/70</strong> &nbsp; | &nbsp;
         Accuracy points: <strong>${accuracyPoints}/30</strong> (penalty ${penalty})<br>
         Hints: <strong>${hintsUsed}</strong> (âˆ’${5*hintsUsed}) &nbsp; | &nbsp;
         Attempts: <strong>${gameState.attempts}</strong> &nbsp; | &nbsp;
         Error: <strong>${epStr}%</strong>`;

      science.innerHTML = `
        <strong>ðŸ“Š Physics check (no air resistance):</strong><br><br>
        Vertical drop (h) = ${h.toFixed(1)} m<br>
        Fall time (t) = âˆš(2h/g) = <strong>${t_theory.toFixed(3)} s</strong><br><br>
        Horizontal distance (d) = ${d.toFixed(1)} m<br>
        Required launch speed (vâ‚€) = d/t = <strong>${v0_theory.toFixed(2)} m/s</strong><br><br>
        Your measured range at target height: <strong>${gameState.measX.toFixed(2)} m</strong><br>
        Percent error (%) = <strong>${epStr}%</strong><br><br>
        Medal thresholds: Gold â‰¤ ${GOLD_MAX}% , Silver â‰¤ ${SILVER_MAX}% , Bronze > ${SILVER_MAX}%
      `;

      screen.classList.remove('hidden');
    }

    function resetAttempt(){
      gameState.moving = false;
      gameState.measured = false;
      gameState.success = false;
      gameState.outcome = "none";

      gameState.x = 0; gameState.y = 0;
      gameState.vx = 0; gameState.vy = 0;
      gameState.t = 0;

      gameState.measT = 0;
      gameState.measX = 0;

      gameState.hitWater = false;
      gameState.splash.active = false;

      gameState.trail = [];
      gameState.trailVisible = false;
      gameState.trailRecording = false;
      gameState.trailHold = 0;

      gameState.energyHistory = [];
      bubble.active = false;

      isPaused = false;
      stepOnce = false;
      updateStatusUI();

      document.getElementById('resultText').innerHTML = '';
      document.getElementById('medalText').textContent = '';
      document.getElementById('measTime').textContent = '0';
      document.getElementById('measDist').textContent = '0';
      document.getElementById('errorPercent').textContent = '0';
    }

    function launch(){
      if (gameState.moving || gameState.measured) return;
      if (soundEnabled) getAudioCtx();

      gameState.attempts++;
      updateAttemptScoreUI();

      isPaused = false;
      stepOnce = false;
      updateStatusUI();

      gameState.moving = true;
      gameState.measured = false;
      gameState.success = false;
      gameState.outcome = "none";

      gameState.x = 0;
      gameState.y = 0;
      gameState.vx = gameState.v0;
      gameState.vy = 0;
      gameState.t = 0;

      gameState.hitWater = false;
      gameState.splash.active = false;

      gameState.energyHistory = [];

      gameState.trail = [{x:0, y:0}];
      gameState.trailVisible = true;
      gameState.trailRecording = true;
      gameState.trailHold = 0;

      bubble.active = false;

      document.getElementById('resultText').innerHTML = '';
      document.getElementById('medalText').textContent = '';
    }

    // Slider wiring (touch-friendly)
    const v0Slider = document.getElementById('v0Slider');
    const hSlider = document.getElementById('hSlider');
    const dSlider = document.getElementById('dSlider');

    function syncSlidersFromState(){
      v0Slider.value = String(gameState.v0);
      hSlider.value = String(h);
      dSlider.value = String(d);
      updateTheory();
    }

    v0Slider.addEventListener('input', () => {
      if (gameState.moving) return;
      gameState.v0 = parseFloat(v0Slider.value);
      updateTheory();
    });

    hSlider.addEventListener('input', () => {
      if (gameState.moving) return;
      h = parseFloat(hSlider.value);
      updateTheory();
      updatePositions();
    });

    dSlider.addEventListener('input', () => {
      if (gameState.moving) return;
      d = parseFloat(dSlider.value);
      updateTheory();
      updatePositions();
    });

    // Keyboard controls (optional)
    document.addEventListener('keydown', (e) => {
      if (e.key === 's' || e.key === 'S') toggleSlowMo();
      else if (e.key === 'p' || e.key === 'P') togglePause();
      else if (e.key === 'n' || e.key === 'N') stepForward();
      else if (e.key === 'k' || e.key === 'K') showHint();
      else if (e.key === 'l' || e.key === 'L') toggleLab();
      else if (e.key === 'm' || e.key === 'M') toggleSound();

      else if (e.key === 'ArrowUp'){
        if (!gameState.moving && !gameState.measured){
          gameState.v0 = Math.min(40, gameState.v0 + 0.5);
          syncSlidersFromState();
        }
        e.preventDefault();
      }
      else if (e.key === 'ArrowDown'){
        if (!gameState.moving && !gameState.measured){
          gameState.v0 = Math.max(5, gameState.v0 - 0.5);
          syncSlidersFromState();
        }
        e.preventDefault();
      }
      else if (e.key === 'ArrowRight'){
        if (!gameState.moving){
          d = Math.min(50, d + 1);
          updateTheory(); updatePositions();
          syncSlidersFromState();
        }
        e.preventDefault();
      }
      else if (e.key === 'ArrowLeft'){
        if (!gameState.moving){
          d = Math.max(5, d - 1);
          updateTheory(); updatePositions();
          syncSlidersFromState();
        }
        e.preventDefault();
      }
      else if (e.key === 'h' || e.key === 'H'){
        if (!gameState.moving){
          h = Math.min(MAX_H, h + 0.5);
          updateTheory(); updatePositions();
          syncSlidersFromState();
        }
      }
      else if (e.key === 'j' || e.key === 'J'){
        if (!gameState.moving){
          h = Math.max(1, h - 0.5);
          updateTheory(); updatePositions();
          syncSlidersFromState();
        }
      }
      else if (e.key === 'r' || e.key === 'R'){
        resetAttempt();
      }
      else if (e.key === ' ' || e.key === 'Spacebar'){
        e.preventDefault();
        launch();
      }
    });

    // Resize safety: keep visual correct (CSS scales the canvas)
    window.addEventListener('resize', () => {
      // No need to change internal resolution; we only re-run positions.
      updatePositions();
    });

    // Start values
    function init(){
      gameState.v0 = 15.0;
      h = 5.0;
      d = 20.0;
      syncSlidersFromState();
      updatePositions();
      updateStatusUI();
      updateAttemptScoreUI();
    }

    // render loop runs continuously (even while the intro screen is visible)
    requestAnimationFrame(gameLoop);

  </script>
</body>
</html>
